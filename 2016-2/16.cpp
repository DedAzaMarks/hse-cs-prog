// В прошлый раз мы рассмотрели иерархию классов с базовым классом Animal
// и производными классами Cat и Dog.
// Если опустить подробности, эта иерархия выглядела так:

#include <string>

class Animal {
public:
    std::string voice() const {
        return "Not implemented";
    }
};

class Cat: public Animal {
public:
    std::string voice() const {
        return "Meow";
    }
};

class Dog: public Animal {
public:
    std::string voice() const {
         return "Woof";
    }
};

// Наследование позволяет неявно приводить объект производного класса к типу базового класса.
// То есть, всякую конкретную кошку или собаку можно рассмотреть просто как животное.

// Этот принцип можно сформулировать так:
// функции, которые используют базовый тип, должны иметь возможность использовать производные типы, не зная об этом.
// Это так называемый принцип подстановки Барбары Лисков, один из важнейших принципов объектно-ориентированного программирования:
// https://en.wikipedia.org/wiki/Liskov_substitution_principle


// Мы хотели создать зоопарк (вектор животных), а затем попросить каждый элемент этого вектора подать голос.
// В векторе могут храниться только однотипные элементы. Попробуем выбрать тип Animal для этого.

#include <iostream>
#include <vector>

int main() {
    Cat c;
    Dog d;

    std::vector<Animal> zoo;
    zoo.push_back(c);
    zoo.push_back(d);

    for (const auto& animal : zoo)
        std::cout << animal.voice() << "\n";
}

// Но почему-то вместо "Meow" и "Woof" мы видим на экране вот это:
// Not implemented
// Not implemented

// Это произошло по двум причинам.
// Во-первых, в векторе всегда хранятся копии элементов, которые мы кладём в него с помощью push_back'а.
// Поэтому в векторе оказалось две копии кошки и собаки, но они имеют тип Animal
// и ничего не знают про исходную специфику кошки и собаки.
// Конечно же, для них вызывается функция из класса Animal.
// Такая копия, имеющая базовый тип, и снятая с объекта производного типа, называется срезкой.

// Чтобы избавиться от срезки, можно было бы заменить явный объект типа Animal на ссылку Animal& или указатель Animal*.
// Тогда исходный объект (типа Cat или Dog) окажется тем же самым.
// Но вектор не может хранить ссылки (потому что они должны бьть сразу же проинициализированы)!
// Поэтому попробуем взять вектор указателей:

int main() {
    Cat c;
    Dog d;

    std::vector<Animal*> zoo;
    zoo.push_back(&c);  // складываем в вектор адреса объектов
    zoo.push_back(&d); 

    for (const auto& animal : zoo)
        std::cout << animal->voice() << "\n";  // теперь надо вызывать функцию через ->, а не через .
}

// Но это не помогло, потому что есть ещё и вторая причина.
// Когда компилятор выбирает, какую функцию вызывать в 72-й строке, он смотрит на тип animal.
// Это Animal *. Поэтому компилятор и вызывает функцию из класса Animal.

// Чтобы решить проблему, нам надо объявить в базовом классе Animal функцию voice виртуальной:

class Animal {
public:
    virtual std::string voice() const {  // виртуальная функция!
        return "Not implemented";
    }
};

// В производных классах можно ничего не менять.
// Но рекомендуется рядом с переопределяемой функцией писать слово override,
// чтобы явно подчеркнуть своё намерение переопределить виртуальную функцию из базового класса:

class Cat: public Animal {
public:
    std::string voice() const override {  
        return "Meow";
    }
};

class Dog: public Animal {
public:
    std::string voice() const override {
         return "Woof";
    }
};

// Теперь наша функция main заработает так, как мы хотели!
// Meow
// Woof

// Использование виртуальных функций, позволяющих переопределить поведение классов-наследников,
// называют ещё полиморфизмом.

// Виртуальные функции устроены так.
// Если в классе хотя бы одна функция объявлена виртуальной,
// то компилятор неявно добавляет к классу ещё одно невидимое поле-указатель.
// Этот указатель может указывать на таблицу виртуальных функций данного класса.
// Конструктор базового класса Animal неявно устанавливает этот указатель на свою таблицу
// (с реализацией, печатающей Not implemented).
// А конструкторы производных классов Cat и Dog неявно переустанавливают его на свои таблицы.

// Когда компилятор видит в тексте программы вызов animal->voice(),
// он понимает, что voice - виртуальная функция.
// И он не подставляет вызов её готового кода,
// а делает это косвенно: в runtime происходит обращение к таблице виртуальных функций объекта *animal,
// и вызывается функция с именем voice с адресом из этой таблицы.

// Такая косвенная адресация не может быть бесплатной: требуется разыменовать дополнительный указатель,
// а ещё такие функции компилятор не сможет заinline'ить (то есть, вставить их код непосредственно в место вызова как есть).
// Поэтому, в отличие от некоторых других языков программирования,
// по умолчанию функции-члены класса не являются виртуальными.


// В примере выше кошка и собака были созданы отдельно на стеке, а в векторе хранились их адреса.
// В частности, время жизни этих объектов были ограничены текущим блоком.
// А что если нам надо в runtime прочитать список животных из файла, и создать зоопарк?
// Вот такая наивная реализация не будет работать:

std::vector<Animal*> factory() {  // такие функции ещё называют фабриками
    std::vector<Animal*> zoo;
    std::string line;
    while (std::cin >> line) {
        if (line == "cat") {
            Cat c;
            zoo.push_back(&c);  // очень опасно!
        } else if (line == "dog") {
            Dog d;
            zoo.push_back(&d);  // ссылки тут же станут "висячими", поскольку объекты c и d живут до конца блока
        }
    }
    return zoo;
}

// Приходится создавать животных в динамической памяти:

std::vector<Animal*> factory() {
    std::vector<Animal*> zoo;
    std::string line;
    while (std::cin >> line) {
        if (line == "cat")
            zoo.push_back(new Cat);
        else if (line == "dog")
            zoo.push_back(new Dog);
    }
    return zoo;
}

// Но теперь кто-то (тот, кто вызывал эту функцию) обязан будет освободить выделенную динамическую память!

int main() {
    auto zoo = factory();
    // ...
    for (Animal* animal : zoo)
        delete animal;
}

// И тут нас подстерегает ещё две опасности.
// Во-первых, мы уже хорошо знаем, что работать с голой динамической памятью опасно:
// если где-то посередине произойдёт исключение, то память утечёт.
// Для этого, в соответствии с идиомой RAII, надо воспользоваться умным указателем:

#include <memory>

std::vector<std::unique_ptr<Animal>> factory() {
    std::vector<std::unique_ptr<Animal>> zoo;
    // Дальше всё то же самое, что и в предыдущей версии функции factory
}

// Но вторая опасность в том, что теперь...
// поведение нашей программы в соответствии со стандартом оказывается неопределенным!
// Смотрите сами. Когда будут умирать умные указатели в векторе, будет неявно вызываться delete animal,
// который неявно вызовет деструктор, но не для класса Cat или Dog, а для базового Animal!
// Этот деструктор тоже следует сделать виртуальным!

// Запомним простое правило: если в классе есть хотя бы одна виртуальная функция
// (и класс предполагается полиморфно использовать),
// то следует определить и виртуальный деструктор
// (либо вообще сделать его protected и не виртуальным, но об этом позже).

// Ещё одно замечание.
// Функцию voice() в базовом классе Animal можно теперь вообще объявить чисто виртуальной вот так:

class Animal {
public:
    virtual std::string voice() const = 0;
};

// У такой функции даже не обязательно должна быть реализация.
// Если в классе есть чисто виртуальная функция, то такой класс считается абстрактным.
// Создать объект такого класса (Animal a) не получится, так как класс считается не полностью определенным.
// Назначение чисто виртуальных функций - потребовать, чтобы наследники переопределили это поведение
// (иначе они тоже будут считаться абстрактными).

// Напишем окончательную программу с учётом всех исправлений:

#include <iostream>
#include <memory>
#include <string>
#include <vector>

class Animal {
public:
    virtual std::string voice() const = 0;
};

class Cat: public Animal {
public:
    std::string voice() const override {  
        return "Meow";
    }
};

class Dog: public Animal {
public:
    std::string voice() const override {
         return "Woof";
    }
};

std::vector<std::unique_ptr<Animal>> factory() {
    std::vector<std::unique_ptr<Animal>> zoo;
    std::string line;
    while (std::cin >> line) {
        if (line == "cat")
            zoo.push_back(new Cat);
        else if (line == "dog")
            zoo.push_back(new Dog);
    }
    return zoo;
}

int main() {
    auto zoo = factory();
    for (const auto& animal : zoo)
        std::cout << animal->voice() << "\n";
    // Созданные в динамической памяти объекты уничтожатся автоматически, так как они
    // обёрнуты в умный указатель.
}

// =================

// Объектно-ориентированное программирование позволяет удобно описать в терминах классов
// предметную область вашей задачи.
// Подмечено, что отношения между классами, как правило, бывают двух типов:
// 1. Отношение HAS-A: объект может владеть (или ссылаться) на другой объект.
// Например, у машины есть мотор, колёса и руль.
// Такое отношение типично реализуется с помощью композиции (агрегации): в классе "машина" будет поле типа "мотор", и т. д.
// 2. Отношение IS-A: объект одного типа является (может рассматриваться как) объект другого типа.
// Например, конкретная модель машины является абстрактной машиной, а та в свой очередь является транспортным средством.
// Такое отношение типично реализуется с помощью публичного наследования.

// ==================

// Давайте напишем иерархию классов, конструкторы и деструкторы которых печатают сообщения.
// Посмотрим, в каком порядке они вызываются.

#include <iostream>

class A {
public:
    A() { std::cout << "A()\n"; }
    ~A() { std::cout << "~A()\n"; }
};


class B: public A {
public:
    B() { std::cout << "B()\n"; }
    ~B() { std::cout << "~B()\n"; }
};


class C {
public:
    C() { std::cout << "C()\n"; }
    ~C() { std::cout << "~C()\n"; }
};


class D: public B  {
public:
    C element;
    D() { std::cout << "D()\n"; }
    ~D() { std::cout << "~D()\n"; }
};


int main() {
    D d;
    std::cout << "Object d created\n";
}

// Мы увидим следующее:
// A()
// B()
// C()
// D()
// Object d created
// ~D()
// ~C()
// ~B()
// ~A()

// Давайте разберёмся, почему.

// Вспомним, что наследование (например, класса B от класса A)
// можно было бы реализовать просто как композицию:
class B1 {
public:
    A base;
};
// Правда, наследование позволяет нам везде писать b.foo вместо b.base.foo для любого имени foo в классе A.

// Поэтому всякий объект производного типа всегда хранит внутри себя так называемый подобъект базового типа.
// Только у него нет явного имени (он отождествляется с самим объектом).

// Что происходит при конструировании объекта d типа D?
// Перед тем, как начнёт выполняться тело его конструктора,
// должны быть проинициализированы все подобъекты базовых типов и все поля.
// Поэтому сначала начинает конструироваться подобъект типа B
// (который в свою очередь сначала инициирует конструирование подобъекта типа A),
// а потом конструируется поле element типа C.

// В деструкторе же всё происходит наоборот: сначала выполняется его тело,
// а затем автомагически вызываются деструкторы для всех полей (в порядке, противоположном их объявлению)
// и для всех подобъектов базовых классов.

// Заметим, что если на каком-то этапе в конструкторе произойдёт исключение,
// то будет сворачиваться стек: все уже проинициализированные к этому моменту поля и подобъекты будут корректно удалены.

