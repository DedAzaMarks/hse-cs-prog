// Мы с вами уже изучили стандартные контейнеры vector, string,
// map/set и unordered_map/unordered_set.
// Познакомимся сегодня ещё с двумя контейнерами.

// Контейнер std::list - двусвязный список.
// Его элементы хранятся в отдельных ячейках памяти.
// Рядом с элементами хранятся ссылки на предыдущую и следующую ячейки.
// В отличие от вектора здесь нет требования, чтобы элементы хранились в памяти подряд.
// Поэтому с двусвязным списком можно эффективно проводить операции добавления/удаления элементов из любой части.
// Можно представлять себе такой список как цепь, любое звено которой можно расковать, чтобы удалить или добавить звенья.

#include <iostream>
#include <list>

int main() {
    std::list<int> container = {3, 14, 15, 92, 6};
    container.push_back(42);
    container.push_front(17);  // можно вставлять элементы и в начале, и в конце

    auto iter = container.begin();
    ++iter;
    ++iter;
    container.insert(iter, 100);  // можно вставлять элементы в середину (на позицию, указанную итератором)

    for (int x : container)
        std::cout << x << " ";
    std::cout << "\n";

    // А можно и так:
    for (auto iter = container.begin(); iter != container.end(); ++iter)
        std::cout << *iter << " ";  // вспомните, что "звёздочка" перед итератором позволяет получить элемент, на которой он ссылается
    std::cout << "\n";
}

// Понятное дело, что std::list не допускает произвольную индексацию:
// не получится обратится к i-му элементу по индексу (container[i] просто не скомпилируется).
// В частности, std::list не получится отсортировать с помощью стандартного std::sort.


// Контейнер std::deque - это сокращение от double-ended queue (двусторонняя очередь)
// Этот контейнер сочетает некоторые преимущества vector'а и list'а.
// Во-первых, к его элементам можно обращаться по индексу с помощью квадратных скобок (как и в векторе).
// Во-вторых, можно эффективно добавлять (или удалять) элементы как в начале, так и в конце.
// Вставка или удаление в середине, как и в векторе, повлечёт за собой сдвиг соседних элементов и не будет эффективной.
// Типичная реализация такого контейнера - набор массивов фиксированного размера, вообще говоря, расположенных в памяти не подряд.

#include <deque>
#include <iostream>

int main() {
    std::deque<int> container = {3, 14, 15, 92, 6};
    container.push_back(42);
    container.push_front(17);  // можно вставлять элементы и в начале, и в конце

    for (int x : container)
        std::cout << x << " ";
    std::cout << "\n";

    // А можно и традиционно:
    for (size_t i = 0; i != container.size(); ++i)
        std::cout << container[i] << " "; 
    std::cout << "\n";

    // Конечно же, можно перебрать элементы такого контейнера и с помощью итераторов тоже.
}

// -----------------------

// Рассмотрим теперь библиотеку algorithm.
// В ней содержатся алгоритмы для работы с последовательностями.
// Типичный уже знакомый нам пример такого алгоритма - сортировка.
// Последовательности задаются с помощью пары итераторов.
// Пара итераторов a, b всегда задаёт полуинтервал [a; b):
// левый конец включается, а правый - нет.

// Все алгоритмы оформлены как шаблонные функции.
// Это позволяет использовать их с любыми контейнерами
// (если только итераторы этих контейнеров позволяют сделать ту или иную операцию).
// Иначе пришлось бы писать свою версию каждого алгоритма для каждого контейнера (и каждого типа элементов в нём).

// Смотрите подробную справку по каждому алгоритму на http://en.cppreference.com/w/cpp/algorithm

// Рассмотрим, наверное, самый простой пример: алгоритм count.
// Эта функция подсчитывает, сколько элементов последовательности равны заданному.
// Конечно, эту задачу можно решить с помощью банального цикла:

#include <vector>

int main() {
    std::vector<int> v = {2, 7, 1, 8, 2, 8};

    int value = 8;
    size_t counter = 0;
    for (int elem : v)
        if (elem == value)
            ++counter;
    // В итоге counter будет равен 2
}

// Однако использование готового стандартного алгоритма всегда предпочтительнее:

#include <algorithm>
#include <vector>

int main() {
    std::vector<int> v = {2, 7, 1, 8, 2, 8};
    size_t counter = std::count(v.begin(), v.end(), 8);
}


// Важно понимать, что алгоритмы стандартной библиотеки - это самые обыкновенные (шаблонные) функции,
// написанные на C++.
// Вы даже можете посмотреть их реализацию, если откроете заголовочный файл algorithm.
// Давайте попробуем в качестве упражнения написать такую функцию самостоятельно:

namespace my_std {  // чтобы наша функция не конфликтовала со стандартной std::count

template <typename Iter, typename Value>  // два шаблонных параметра: тип итератора и тип эталонного элемента
size_t count(
    Iter first,  // обратите внимание: по стандартному соглашению итераторы передаются в функции по значению
    Iter last,
    const Value& v  // а вот прочие элементы неизвестных заранее типов - по константной ссылке
) {
    size_t counter = 0;
    while (first != last) {  // смело можем менять first, это всё равно копия
        if (*first == v)
            ++counter;
        ++first;  // сдвигаем итератор к следующему элементу
    }
    return counter;
}

}  // end of namespace my_std

#include <list>

int main() {
    std::list<int> v = {2, 7, 1, 8, 2, 8};  // алгоритм count будет работать с любым контейнером
    std::cout << my_std::count(v.begin(), v.end(), 8) << "\n";
}


// Теперь рассмотрим алгоритм find.
// Этот алгоритм ищет последовательным перебором первое вхождение элемента, равного заданному.
// Результатом является итератор, ссылающийся на найденный элемент (или равный правому концу полуинтервала, если ничего не найдено).

// Вот его возможная реализация:

template <typename Iter, typename Value>
Iter find(
    Iter first,
    Iter last,
    const Value& v)
{
    while (first != last) {
        if (*first == v)
            return first;
        ++first;
    }
    return last;
}

#include <algorithm>
#include <deque>
#include <iostream>

int main() {
    std::deque<int> d = {3, 14, 15, 92, 6};
    auto iter = std::find(d.begin(), d.end(), 15);  // такой элемент есть, мы его точно найдём
    std::cout << (iter - d.begin()) << "\n";  // итераторы дека можно вычитать, напечатается индекс найденного элемента

    // Конечно, алгоритмы можно применять не только ко всем элементам контейнера целиком, но и к поддиапазонам:
    auto start = d.begin();
    auto end = start + 3;  // к итераторам дека (и вектора) можно прибавлять целые числа
    // Полуинтервал [start; end) теперь ограничивает подпоследовательность 3, 14, 15

    auto it = std::find(start, end, 19);
    if (it == end) {
        std::cout << "No such element!\n";
    } else {
        std::cout << *it << "\n";
    }
}


// Вопросы на понимание.

#include <algorithm>
#include <map>
#include <string>
#include <utility>  // для std::pair

int main() {
    std::map<int, std::string> m;
    m[17] = "hello";

    // Какие из этих способов скомпилируются? Какой будет эффективнее?
    auto it1 = m.find(17);   // (1)
    auto it2 = std::find(m.begin(), m.end(), 17);  // (2)
    auto it3 = std::find(m.begin(), m.end(), std::pair<const int, std::string>(17, "hello"));  // (3)

    // Ответ:
    // (1) - этот способ самый эффективный, так как встроенный поиск элемента в контейнере map выполняется за логарифмическое время
    // (2) - этот способ не скомпилируется. Элементы контейнера - это пары из константного ключа и значения, а не просто ключи.
    // (3) - этот способ возможен, но поиск будет выполняться за линейное время обычным перебором, то есть, неэффективно.

    // Вывод:
    // Важно понимать, что стандартные алгоритмы являются обобщенными, и ничего не знают
    // о физическом способе хранения элементов в контейнере.
    // Иногда некоторые операции можно выполнить эффективнее.
    // В таких случаях в контейнере предусмотрены встроенные функции.
}


// Иногда бывает удобно применить тот или иной алгоритм (count, find, и т. д.) не для конкретного значения,
// а для любого элемента, удовлетворяющего некоторому условию.
// Такое условие можно оформить, например, в виде функции, получающей на вход элемент и возвращающей true/false.
// Такие функции называют ещё предикатами.
// Для этого имеются алгоритмы, в названии которых добавляется суффикс _if:

// Например, найдём первый символ в строке, являющийся заглавной латинской буквой.
// Напишем такую функцию:

bool is_upper(char c) {
    return 'A' <= c && c <= 'Z';
}

// Передадим этот предикат в find_if:

#include <algorithm>
#include <iostream>
#include <string>

int main() {
    std::string s;
    std::cin >> s;

    auto iter = std::find_if(
        s.begin(),
        s.end(),
        is_upper  // обратите внимание, что тут нет никаких круглых скобок
    );
    
    size_t pos = iter - s.begin();  // получаем позицию этого символа (или длину всей строки, если такого не нашлось)
    std::cout << pos << "\n";
}

// Иногда бывает удобнее не описывать предикат отдельно, называя его отдельным именем,
// а дать его определение прямо в месте использования.
// Это можно сделать с помощью лямбда-функции:

#include <algorithm>
#include <string>

int main() {
    std::string s = "iPhone";

    auto iter = std::find_if(
        s.begin(),
        s.end(),
        [](char c) {  // описание лябмда-функции начинается с квадратных скобок
            return 'A' <= c && c <= 'Z';
        }
    );
}

// Известная шутка: после появления лямбда-функций в C++11
// следующая программа должна компилироваться:
int main(){[](){}();}
// Разберитесь-ка, что здесь происходит!


// Напишем для примера собственную реализацию алгоритма find_if:
namespace my_std {
template <typename Iter, typename Predicate>  // обратите внимание, что тип предиката - это просто шаблонный параметр
Iter find_if(Iter first, Iter last, Predicate p) {
    while (first != last) {
        if (p(*first)) {
            return first;
        ++first;
    }
    return last;
}
}  // end of namespace my_std


// Наконец рассмотрим алгоритм copy.
// Этот алгоритм копирует содержимое одной последовательности в другое место.
// Вот пример использования:
#include <algorithm>
#include <iostream>
#include <vector>
#include <list>

int main() {
    std::vector<int> v = {3, 14, 15, 92, 6};
    std::list<int> l;
    // ...
    l.resize(v.size());  // теперь в списке l 5 нулей
    // В контейнере, в который мы копируем элементы, должно быть достаточно места, чтобы они поместились!
    // Если бы мы не сделали предыдущий resize, то программа попала бы в неопределенное поведение!
    std::copy(v.begin(), v.end(), l.begin());  // теперь в l те же элементы, что и в v

    for (int x : l) 
        std::cout << x << " ";
    std::cout << "\n";
}

// Вот возможная реализация алгоритма copy:
namespace my_std {

template <typename InputIter, typename OutputIter>
void copy(InputIter first, InputIter last, OutputIter out) {
    for (auto cur = first; cur != last; ++cur, ++out) {
        *out = *cur;
    }        
}

}

