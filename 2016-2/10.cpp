// Ключевое слово static в C++ используется в нескольких разных смыслах.
// Сегодня мы рассмотрим статические поля или функции в классе.

// Вспоминаем, что класс в первую очередь - это пользовательский тип данных.
// Мы можем описать в классе поля и функции-члены,
// и у каждой переменной (объекта) нашего класса будут своии экземпляры таких полей,
// и для каждого такого объекта можно будет вызвать функцию-член.
// Это - обычные (нестатические) поля и функции.
// Наоборот, статические поля и функции стоит рассматривать как помещённые в класс просто как в пространство имён.
// Существует лишь один экземпляр статического поля на весь класс (он общий для всех объектов).
// Статическая функция ничего не знает про конкретный объект (можно тоже сказать, что она общая для всего класса).

#include <iostream>

class C {
public:
    static int counter;  // статическое поле
    static void foo() {  // статическая функция
    }
    void bar() {  // обычная функция-член
    }
    int x;  // обычное поле
};

int C::counter = 0;  // статическое поле надо обязательно проинициализировать как глобальную переменную

int main() {
    C::counter = 1;  // обращаемся к статическому полю просто как к переменной,
    std::cout << C::counter << "\n";  // помещённой в "пространство имён" C
    C c1, c2, c3;
    c1.x = 42;  // а обычные поля "привязаны" к конкретным объектам класса - c1, c2, c3
    c2.x = 17;
    c3.x = -1;
    C::foo();  // статическую функцию вызываем просто как функцию из "пространства имён" C
    c1.bar();  // обычные функции-члены знают про объект, для которого они вызваны (c1, c2, c3)
    c2.bar();
    c3.bar();
}


// Воспользуемся статической переменной, чтобы подсчитывать количество когда-либо созданных объектов.
// В свою очередь, у каждого объекта заведем обычное поле с его уникальным порядковым номером.
// Изменять счётчик объектов будем в конструкторе объектов.

#include <iostream>

class MyClass {
private:
    static int counter;
public:
    const int id;
public:
    MyClass(): id(++counter) {  // увеличиваем глобальный счётчик и инициализируем id текущего объекта
        std::cout << "MyClass() " << id << "\n";  // пусть каждый конструктор напишет о том, что его вызвали
    }

    // Обычно компилятор предоставляет автоматически конструктор по умолчанию (без аргументов),
    // конструктор копирования, оператор присваивания и деструктор.
    // Мы можем переопределить их при необходимости.

    // Переопределим конструктор копирования, который должен создавать новый объект по образцу того же типа.
    // Конструктор копирования, предоставляемый автоматически компилятором, просто копирует все поля образца.
    // Нам же нужно, чтобы у нового объекта поле id не было скопировано с образца, а было проинициализировано новым значением.
    // К тому же, нам нужно напечатать отладочную информацию.
    MyClass(const MyClass& other): id(++counter)
    {
        std::cout << "MyClass(const MyClass&) " << id << " " << other.id << "\n";
    }

    // Оператор присваивания.
    // Кстати, автоматически оператор присваивания по умолчанию для нашего класса не мог бы быть сгенерирован,
    // поскольку константе id нельзя присвоить новое значение.
    MyClass& operator = (const MyClass& other) {
        std::cout << "operator = (const MyClass&) " << id << " " << other.id << "\n";
        return *this;  // как и во всяком операторе присваивания, возвращаем здесь ссылку на себя
    }

    // По-хорошему, надо было бы ещё объявить 

    // Деструктор.
    // Он вызывается автоматически, когда объект "умирает".
    // Его задача - освободить ресурсы.
    // Наш же деструктор просто напечатает сообщение на экране.
    ~MyClass() {
        std::cout << "~MyClass() " << id << "\n";
    }
};

int MyClass::counter = 0;  // инициализируем глобальный счётчик объектов

int main() {
    MyClass c1;
    MyClass c2 = c1;  // Внимание! Это не присваивание, а инициализация нового объекта через конструктор копирования
    MyClass c3;
    c3 = c1;  // а вот это уже оператор присваивания
}

// На экране мы увидим такой лог:
MyClass() 1  // создали объект c1 (строка 97)
MyClass(const MyClass&) 2 1  // создали объект с2 (строка 98)
MyClass() 3  // создали объект с3 (строка 99)
operator = (const MyClass&) 3 1  // вызвали оператор присваиваниия для c3 (строка 100)
~MyClass() 3  // автоматически вызываются деструкторы для переменных
~MyClass() 2  // при достижении ближайшей закрывающей фигурной скобки
~MyClass() 1  // в порядке, обратном созданию переменных (строка 101)


// Теперь попробуем сложить элементы нашего типа в контейнер.
// Начнем с std::list:

#include <list>

int main() {
   std::list<MyClass> container;
   container.push_back(MyClass());
   MyClass c;
   container.push_back(c);
}

// Вывод на экран зависит от конкретной реализации контейнера в вашей стандартной библиотеке.
// Будет примерно следующее:
MyClass() 1  // создаём временный объект MyClass(), который передаётся в push_back (строка 115)
MyClass(const MyClass&) 2 1  // этот объект копируется в контейнер (так как объект в контейнере должен "пережить" наш временный объект)
~MyClass() 1  // временный объект умирает
MyClass() 3  // создаётся объект c (строка 116)
MyClass(const MyClass&) 4 3  // объект c копируется в контейнер (строка 117)
~MyClass() 3  // умирает объект c (строка 118)
~MyClass() 2  // умирает контейнер: сначала умирает его первый элемент 
~MyClass() 4  // умирает второй элемент контейнера

// Заметим, что вместо push_back можно было бы воспользоваться функцией emplace_back.
// Она принимает на вход не сам объект, копию которого надо поместить в контейнер,
// а аргументы конструктора объекта, и создаёт новый объект сама:

int main() {
   std::list<MyClass> container;
   container.emplace_back();
   container.emplace_back();
}

// Вывод на экран:
MyClass() 1  // строка 137
MyClass() 2  // строка 138
~MyClass() 1  // строка 139
~MyClass() 2


// Теперь положим элементы в вектор:

#include <vector>

int main() {
    std::vector<MyClass> container;
    container.emplace_back();
    container.emplace_back();
    std::cout << "Bye-bye!\n";
}

// Вывод, опять же, зависит от реализациии std::vector и будет примерно таким:
MyClass() 1  // создаём первый объект в векторе (строка 154)
MyClass() 2  // создаём второй объект в векторе
MyClass(const MyClass&) 3 1  // но что это?
~MyClass() 1
Bye-bye!
~MyClass() 3
~MyClass() 2

// Ответ: это произошла реаллокация.
// После первого emplace_back'а в векторе была память только под один элемент.
// Когда выполнился второй emplace_back, произошло следующее:
//   а) выделился новый кусок сырой памяти, достаточный для хранения двух элементов;
//   б) в нём был создан новый (второй) элемент на нужном месте - это строчка "MyClass() 2" в логе;
//   в) туда был скопирован первый элемент из старого куска памяти - это третья строчка лога.
//   г) элемент в старой части памяти был уничтожен - это четвёртая строчка лога.


// Рассмотрим теперь такой пример:

MyClass factory() {
    MyClass c;
    // ...
    return c;
}

int main() {
    MyClass c1 = factory();  // инициализируем c1 временным объектом - возвращаемым значением функции
    std::cout << c1.id << "\n";
}

// Скомпилировав программу с опциями компилятора по умолчанию, мы бы, наверное, увидели следующее:
MyClass() 1
1
~MyClass() 1

// Тут явно пропущен вызов конструктора: ведь по идее объект должен создаваться и в функции factory, и в функции main.
// Это потому, что компилятор имеет право оптимизировать такой код в простых случаях и выкидывать "лишние" конструкторы
// (даже если они имеют "побочные эффекты" типа нашей печати сообщений на экран).
// Это называется return value optimization, и до move-конструкторов в C++11 это был чуть ли не единственный способ
// избежать лишних "паразитных" копирований при возвращении значений из функций.
// Заметим, что эта оптимизация может сработать далеко не всегда: если функция сложная, то она не сработает.

// Давайте отключим эту оптимизацию
// (в clang++ и в g++ это делается ключом -fno-elide-constructors):
MyClass() 1  // это создаётся объект c внутри функции factory
MyClass(const MyClass&) 2 1  // он возвращается из функции по значению, происходит копирование во временный объект
~MyClass() 1  // объект c внутри функции умирает
MyClass(const MyClass&) 3 2  // это инициализируется c1 внутри main
~MyClass() 2  // умирает временный объект, возвращённый из функции
3
~MyClass() 3  // умирает c1

// В С++11 появилась возможность создавать новые объекты на основе временных (безымянных) объектов
// и при этом обойтись без лишних (потенциально дорогих) копирований.
// Для этого в классе можно так же определить так называемый конструктор перемещения,
// получающий на вход rvalue-ссылку:

class MyClass {
public:
    // ...

    MyClass(MyClass&& other) {  // обратите внимания на && - это rvalue-ссылка, по которой можно передать временный объект
        std::cout << "MyClass(MyClass&&) " << id << " " << other.id << "\n";
    }
};

// Такой конструктор будет вызван, когда на вход передаётся временный (безымянный) объект,
// который всё равно вот-вот умрёт.
// В некоторых случаях бывает выгоднее отобрать у такого объекта все данные, чем копировать их.
// Подробнее про такие вещи мы поговорим в третьем модуле: такие конструкторы
// помогут нам спроектировать и свою реализацию класса vector, и свою реализацию умных указателей.

// А теперь посмотрим, как будет работать предыдущий пример (если снова включить опцию -fno-elide-constructors):
MyClass() 1 
MyClass(MyClass&&) 2 1 
~MyClass() 1
MyClass(MyClass&&) 3 2
~MyClass() 2
3
~MyClass() 3
// Всё похоже, но теперь вместо конструктора копирования вызывается move-конструктор,
// который (в случае сложных классов) может быть устроен гораздо проще, чем конструктор перемещения.
// Например, для контейнера такой конструктор может просто "забрать" память у другого контейнера, а не копировать её.

// Передать в move-конструктор можно и обычный (именованный) объект,
// но для этого его надо обернуть в std::move:

#include <utility>

int main() {
    MyClass c1;
    MyClass c2 = std::move(c1);  // забрали всё, чем владел c1
}

// Получится так:
MyClass() 1
MyClass(MyClass&&) 2 1
~MyClass() 2
~MyClass() 1

