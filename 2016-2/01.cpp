// Disclaimer: не пытайтесь скомпилировать этот файл целиком как есть.
// Тут собраны фрагменты разных программ, которые нужно компилировать и запускать по отдельности.

// Пояснения по коду будут оформляться как комментарии
// (однострочные комментарии начинаются с //, многострочные ограничиваются /* и */).

// Ссылка на один из последних черновиков стандарта C++14: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf

// ============================

// Простейшая программа на C++ (которая ничего не делает):
int main() {
}

// Мы здесь объявили функцию main, с которой всегда начинается исполнение программы.
// Наша функция не получает никаких аргументов.
// Считается, что функция main должна возвращать целое число (значение типа int).
// Причем это число равно 0, если программа завершилась успешно.
// А если оно отлично от 0, то оно может обозначать код ошибки.

// Если функция имеет тип int, то из нее обязательно нужно что-то вернуть с помощью оператора return.
// Но для функции main сделано исключение: return 0 можно не писать. А можно было бы написать:

int main() {
    return 0;  // В функции main разрешается опускать этот return 0
}

// По умолчанию main всегда возвращает 0. Это значит, что программа завершилась успешно.

// Скомпилируем программу из консоли с помощью компилятора clang++ и получим исполняемый файл binary:
// clang++ 01a.cpp -o binary

// Запустим программу:
// ./binary


// ============================

// Теперь напишем традиционный "Hello, world!"

#include <iostream>

int main() {
    std::cout << "Hello, world!\n";
}

// Здесь мы передаем строку (с завершающим символом перевода строки) в cout, то есть, на консоль (console output).
// Директива #include ... подключает заголовочный библиотечный файл с именем iostream,
// в котором определен объект cout.

// std:: - это префикс пространства имен, в котором собраны стандартные библиотечные сущности.


// ============================

// Напишем программу, спрашивающую имя пользователя

#include <iostream>
#include <string>  // Требуется для типа std::string

int main() {
    std::string name;  // Объявляем переменную name типа std::string
    std::cin >> name;  // Считываем ее с клавиатуры. Обратите внимание на направление стрелок!
    std::cout          // Длинные конструкции можно для удобства разбивать на несколько строк.
        << "Hello, "
        << name
        << "!\n";      // Оператор в любом случае должен заканчиваться точкой с запятой.
}


// ============================

// Рассмотрим "встроенные" в язык простые типы данных.
// Компилятор должен знать, сколько ячеек памяти занимает значение каждого из типов.
// Эта величина фиксирована и не может меняться в процессе работы программы.

#include <iostream>

using std::cout;  // Чтобы не писать везде std:: перед cout.

int main() {
    char ch = '@';  // Символ (как правило занимает один байт). Обратите внимание, что символы записываются в апострофах.
    bool b = true;  // Логическая переменная, может принимать значения false и true
    int i = 42;  // Целое число, занимает как правило 4 байта
    float f = 2.71828;  // Дробное число с плавающей запятой
    double x = 3.1415;  // Дробное числов повышенной точности
    long int l = 12321321312;  // Длинное целое (как правило, 8 байт)
    long double xx = 1e15;  // Длинное дробное (как правило, 16 байт)

    cout << ch << "\n"; 
    cout << b << "\n"; 
    cout << i << "\n"; 
    cout << f << "\n"; 
    cout << x << "\n"; 
    cout << l << "\n"; 
    cout << xx << "\n"; 

    // Стандарт языка не накладывает жёстких ограничений на размеры типов,
    // они могут отличаться для разных платформ и компиляторов.
    // Оператор sizeof вычисляет (на этапе компиляции) размер переменной или типа в единицах размера типа char.
    cout << "char: " << sizeof(ch) << "\n";          // у меня - 1
    cout << "bool: " << sizeof(b) << "\n";                   //  1
    cout << "int: " << sizeof(int) << "\n";                  //  4
    cout << "float: " << sizeof(float) << "\n";              //  4
    cout << "double: " << sizeof(double) << "\n";            //  8
    cout << "long int: " << sizeof(long int) << "\n";        //  8
    cout << "long double: " << sizeof(long double) << "\n";  // 16

}


// ============================

// Простейший диалог с пользователем:

#include <iostream>
#include <string>

// чтобы не писать std::, в больших проектах не рекомендуется из-за возможного конфликта имён из разных библиотек
using namespace std;  

int main() {
   cout << "What is your name?\n";
   string name;
   cin >> name;

   cout << "How old are you?\n";
   int age;
   cin >> age;

   if (age < 0) {  // условный оператор (условие должно быть в скобках)
       cout << "Wrong age!\n";
       return 1;  // завершим программу с ненулевым кодом возврата
   }

   cout << "Your birth year is " << (2016 - age) << "\n";
}

// Можно было бы повторно попросить пользователя ввести возраст, если он некорректен.
// Воспользуемся первый и последний раз оператором безусловного перехода goto (ругательным словом из четырёх букв):
// (здесь и далее директивы #include и using ... для краткости опускаются).
int main() {
   cout << "What is your name?\n";
   string name;
   cin >> name;

   label:  // метка, на которую можно прыгнуть
   cout << "How old are you?\n";
   int age;
   cin >> age;

   if (age < 0) {
       cout << "Wrong age!\n";
       goto label;  // переходим на метку
   }

   cout << "Your birth year is " << (2016 - age) << "\n";
}

// Считается, что оператор goto затрудняет чтение кода. Любую программу можно переписать без него.
// В некоторых языках (в том же python'е) этого оператора намеренно нет.
// Почему же его оставили в C++? Какие были причины кроме обратной совместимости с C?
// Оказывается он очень удобен, например, в автоматически генерируемых программах
// (реализующих, скажем, конечный автомат)


// ============================

// Перепишем ту же программу с помощью цикла:
int main() {
   cout << "What is your name?\n";
   string name;
   cin >> name;

   int age;
   do {
       cout << "How old are you?\n";
       cin >> age;

       if (age < 0)
           cout << "Wrong age!\n";
   } while (age < 0);  // продолжаем цикл пока условие истинно

   cout << "Your birth year is " << (2016 - age) << "\n";
}

// Или можно было бы написать формально бесконечный цикл while (true) { ... }
// и выйти в нужный момент из него с помощью оператора break.


// ============================

// Напечатаем таблицу квадратов чисел от 1 до 10 несколькими способами:

#include <iostream>

using std::cout;

int main() {
    // Первый способ: цикл с предусловием
    int n = 1;
    while (n <= 10) {
        cout << n << "\t" << n * n << "\n";  // выводим число и его квадрат через табуляцию
        ++n;  // увеличиваем n на единицу
    }

    // Второй способ: цикл с постусловием
    n = 1;  // n уже задекларировано выше, поэтому тип не пишем
    do {
        cout << n << "\t" << n * n << "\n";
        ++n;
    } while (n <= 10);
    // Создатель C++ Бьярн Страуструп не любит цикл с постусловием,
    // и рекомендует всегда стараться использовать цикл с предусловием вместо него.


    // Третий способ: цикл for     
    for (int n = 1; n <= 10; ++n)
        cout << n << "\t" << n * n << "\n";
    // В заголовке цикла for три секции:
    // инициализация; условие продолжения цикла; выражение, вычисляющаеся после каждой итерации
}


// ============================

// Напечатаем таблицу умножения с помощью вложенных циклов

#include <iostream>

using std::cout;

int main() {
    for (int i = 1; i != 10; ++i) {
        for (int j = 1; j != 10; ++j) {
            cout << i * j << "\t";
        }
        cout << "\n";
    }
}

// Не наступите на грабли: если поставить точку с запятой после заголовка цикла, то в цикле будет крутиться пустой оператор.


// ============================

// Теперь напишем простейший калькулятор
#include <iostream>

using std::cin;
using std::cout;

int main() {
    int a, b;
    cin >> a >> b;  // сначала вводятся два целых числа
    char operation;
    cin >> operation;  // затем - символ операции

    int result;
    if (operation == '+')
        result = a + b;
    else if (operation == '-')  // обратите внимание на оформление блоков else if
        result = a - b;
    else if (operation == '*')
        result = a * b;
    else if (operation == '/')
        result = a / b;
    
    cout << result << "\n";
}

// Вопрос первый: что будет, если ввести 2 3 / ?
// Ответ: получится 0. Потому что деление целых положительных чисел в C++ - это всегда неполное частное.

// Вопрос второй: что будет, если ввести 2 3 @ ?
// Ответ: поведение программы станет неопределённым. Она напечатает какое-то неизвестное заранее случайное число
// (особенно если скомпилировать программу с опцией -O2, включающей оптимизацию кода).
// Локальные переменные простых типов (как наша result) по умолчанию никак не инициализируются.
// Что лежало до этого в кусочке памяти, который достался этой переменной - никому не известно.
// Почему они не инициализируются по умолчанию? Да потому что принцип C++ - не платить за то, что не требуется.


// ============================

// То же самое, но с оператором множественного выбора switch:
#include <iostream>

using std::cin;
using std::cout;

int main() {
    int a, b;
    cin >> a >> b;
    char operation;
    cin >> operation;

    int result;
    switch (operation) {  // работает только для простых интегральных типов - int, char, bool и т. д.
    case '+':  // воспринимайте эти case просто как расставленные в коде условные метки, на которые мы попадаем из заголовка switch
        result = a + b;
        break;  // если не требуется, чтобы мы выполняли все остальные команды 
    case '-':
        result = a - b;
        break;
    case '*':
        result = a * b;
        break;
    case '/':
        result = a / b;
        break;
    default:  // Если ни одна из меток не подошла. Не опечатайтесь в этом слове, а то получится кое-что интересное :)
        result = 0;
    }
    
    cout << result << "\n";
}


// ============================

// Последний сюжет на сегодня - сложные условия
int main() {
    int a = 1, b = 2;
    // ...
    if (0 <= b && b < 10) {  // двойное неравенство надо проверять именно так; && означает "И"
        // ...
    } else if (b < -20 || b > 20) {  // || означает "ИЛИ". Обратите внимание, что приоритет у сравнений выше чем у логических операторов.
        // ...
    } else if (!(b > 20 || b < -20)) {  // ! - это отрицание
        // ...
    } else if (b == 20) {  // проверка на равенство
        // ...
    } else if (b != -20) {  // проверка на неравенство
        // ...
    } else {
        // ...
    }
}
