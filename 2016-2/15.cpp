// Наша цель на сегодня - написать примерную реализацию класса shared_ptr
// Напомним, что shared_ptr - это "умный указатель" с подсчётом количества ссылок на объект.
// Поэтому такие указатели можно копировать (при этом увеличивается счётчик).
// Ответственным за уничтожение хранящегося объекта и освобождение динамической памяти
// является последний умирающий shared_ptr.

// Первый вопрос: а как и где должен храниться этот счётчик ссылок?
// Рассмотрим сначала два наивных и неправильных варианта, которые часто предлагают студенты.

template <typename T>
class shared_ptr {
private:
    T * ptr;  // сам указатель, которым мы владеем
    size_t counter1;  // годится ли такой счётчик ссылок?
    static size_t counter2;  // или же он должен быть статическим?
    static std::map<T*, size_t> counter3;  // некоторые студенты вообще пишут вот так, чтобы по указателю получить число ссылок...
};

// Так делать не надо.
// Счётчик counter1 будет свой у каждого объекта shared_ptr, и его не получится синхронизировть у разных его копий.
// Счётчик counter2 будет вообще глобальным (для каждого типа T), и не получится завести два разных shared_ptr'а, владеющих разной памятью.
// Счётчик counter3 будет работать, но неэффективно (и по памяти, и по скорости).

// Правильное решение: хранить счётчик в динамической памяти:

template <typename T>
class shared_ptr {
private:
    T * ptr;
    size_t * counter;  // копии нашего объекта будут хранить указатели на одно и то же место в памяти, где хранится счётчик
};

// Но надо аккуратно написать код, выделяющий и освобождающий память для хранения счётчика.


// Сделаем важную оговорку.
// Мы напишем сейчас однопоточную версию умного указателя.
// В многопоточных программах потребуются дополнительные усилия, для того, чтобы во время изменении счётчика в одном потоке
// другой поток не мог бы получить к нему доступ.
// Для этого счётчик надо будет делать "атомарным".
// Многопоточность мы в этом курсе не рассматриваем, поэтому и напишем упрощённую версию.

namespace mystd {

template <typename T>
class shared_ptr {
private:
    T * ptr;
    size_t * counter;

public:
    shared_ptr()
        : ptr(nullptr)  // по умолчанию shared_ptr не хранит ничего
        , counter(nullptr)
    {}

    explicit shared_ptr(T * raw_ptr)  // инициализируем указателем на только что выделенную динамическую память
        : ptr(raw_ptr)
        , counter(new size_t(1))  // создаём новый счётчик со значением 1
    {
        // ToDo: в new при инициализации counter'а может произойти исключение!
        // в этом случае надо удалить ptr!
    }

    shared_ptr(const shared_ptr& other)  // копирование: надо увеличить счётчик ссылок
        : ptr(other.ptr)
        , counter(other.counter)
    {
        ++counter;  // Тут есть очень коварный баг! Видите его?
    }

private:  // для удобства чтения кода разместим эту секцию здесь
    void release() {  // вспомогательная функция для освобождения ресурсов
         // Она будет вызываться в деструкторе и в операторе присваивания
         // ToDo: проверить на nullptr
         --*counter;

         if (*counter == 0) {
             delete ptr;
             delete counter;
         }
    }

public:
    ~shared_ptr() {
        release();
    }
   
    shared_ptr& operator = (const shared_ptr& other) {  // оператор присваивания
        // Помните: в отличие от конструктора, где создаётся новый объект с нуля,
        // в операторе присваивания левая часть уже существовала.
        // Поэтому надо освободить владение ресурсом.
        release();
        ptr = other.ptr;
        counter = other.counter;
        ++*counter;
        return *this;
    }
    // ToDo: напишите также оператор присваивания, получающий на вход unique_ptr.

    void reset(T * raw_ptr) {  // овладеть новой сырой памятью
        // ToDo: дописать эту функцию
    }

    T& operator * () const {  // наш умный указатель должен уметь разыменовываться как обычный указатель
        return *ptr;
    }

    T* operator -> () const {  // в операторе -> достаточно вернуть что-то, к чему можно применить обычную стрелочку
        return ptr;
    }

    size_t use_count() const {
        return *counter;
    }

    // В классическом shared_ptr есть ещё и такие функции:
    void swap(shared_ptr& other);  // для обмена содержимым с другим умным указателем
    T * get() const;   // для получения самого указателяф
    explicit operator bool() const;  // для проверки на отличие указателя от nullptr
};

}

// Проверка:
int main() {
    mystd::shared_ptr<int> p1(new int(17));
    auto p2(p1);  // копирование
    mystd::shared_ptr<int> p3(new int(123));
    p3 = p2;
    p3.reset(new int(13));
    std::cout << *p3 << "\n";
    std::cout << p3.use_count() << "\n";
}

// Помните, что с умными указателями всё равно можно выстрелить себе в ногу, если их использовать неправильно или не по назначению:
int main() {
    int * x = new int(123);
    // ...
    std::shared_ptr<int> sp1(x);  // плохо: память была выделена сильно раньше и на неё ссылается x, который можно неаккуратно использовать
    delete x;  // опасно! когда умрёт sp1, будет двойной delete.
    std::shared_ptr<int> sp2(x);  // опасно! теперь sp1 и sp2 владеют одной и той же памятью!
}

// Правильный сценарий использования такой:
int main() {
    std::shared_ptr<int> p1(new int(123));
    // Или можно вызвать удобную функцию make_shared, которая сама вызывает new с указанными аргументами и возвращает умный указатель:
    auto p2 = std::make_shared<int>(123);
    // Аналогичная функция есть и для unique_ptr (начиная с C++14):
    auto p3 = std::make_unique<int>(123);
}


// =========================

// Изучим теперь наследование.
// Наследование - это способ организовывать иерархии классов.
// При этом класс-наследник приобретает (неприватные) поля, функции-члены и т. д. базового класса
// (быть может, модифицируя их область видимости).
// А с точки зрения памяти сначала в ней размещается подобъект базового класса, а затем уже - поля производного класса.

// Язык C++ - один из немногих языков с множественным наследованием.
// Множественное наследование считается сложным (и не всегда оправданным). Мы намеренно не будем здесь его рассматривать.

// Базовый класс:
class Base {
public:
    Base(int x) {
        // какой-то конструктор
    }
    int a;
    double b;
    void f() const {
    }
private:
    int z;
    void g() {
    }
};

// Производный класс
class Derived: public Base {  // public-наследование: все public-поля остаются public-полями в наследнике
public:
    Derived(double y)
    : Base(42)  // подобъект базового класса необходимо проинициализировать вызовом конструктора
    , a(y)  // и только потом инициализируются поля
    , b(0)
    , c(-1)
    {
    }
    float a;
    long b;
    void h() const {
    }
private:
    int c;
};

// А можно было бы организовать класс так:
class Derived2 {  // наследования нет
public:
    Base base;  // вместо базового класса просто поле типа base
    float a;
    long b;
    void h() const {
    }
    Derived2(): base(42) {}  // его мы тоже инициализируем, но как обычное поле
private:
    int c;
}; 
// Такая организация данных называется "композицией".
// (Есть рекомендация предпочитать композицию наследованию, но сегодня речь всё-таки о наследовании.)

void foo(const Base& b) {
}

int main() {
    Derived d1;
    Derived2 d2;

    d1.a;
    d1.Base::a;
 
    foo(d1);  // объект производного класса может быть автоматически преобразован к типу базового класса
    foo(d2.base);  // а вот во втором случае придётся везде явно писать имя поля .base.
}


// ==============

// Теперь напишем хрестоматийный пример - сделаем иерархию животных с базовым классом Animal

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

class Animal {
  public:
    Animal(const std::string& name)
    :name_(name) {
    }
    std::string voice() const {  // каждое животное будет по-своему подавать свой голос
        return "Not implemented yet";
    }
    const std::string& name() const {
        return name_;
    }
  
  private:
    std::string name_;  // у животных есть имя
};

class Cat: public Animal {
  public:
    Cat(const std::string& name, int color)
    : Animal(name)
    , color_(color)
    {
    }

    std::string voice() const {
         return "Meow";
    }

  private:
    int color_;  // у кошки есть цвет
};

class Dog: public Animal {
  public:

    Dog(const std::string& name, int breed, int color)
    : Animal(name)
    , breed_(breed)
    , color_(color)
    {
    }

    std::string voice() const {
        return "Woof!";
    }

  private:
    int breed_;  // у собаки есть порода
    int color_;
};


int main() {
    Cat c("Tom", 1);
    Dog d("Buffa", 2, 3);

    std::cout << c.voice() << "\n";  // Печатает "Meow"
    std::cout << d.voice() << "\n";  // Печатает "Woof!"

    // Но что если мы хотим сделать вектор животных?
    // Элементы вектора должны иметь один и тот же тип.
    // Если это будет просто Animal, то мы не сможем восстановить специфичные данные для кошки/собаки по таким элементам.
    // Ссылкой Animal& это тоже быть не может (ссылка должна быть проинициализирована сразу же).
    // Это может быть указатель!

    std::vector<Animal> animals;
    animals.push_back(c);
    animals.push_back(d);
    
    for (const auto& a : animals)
        std::cout << a.voice() << "\n";
    // Почему-то этот цикл печатает два раза "Not implemented yet"!

    // Так как вектор состоит из объектов типа Animal, то в него кладутся "срезки" - подобъекты базового класса.
    // Конечно же, функция voice для них работает так, как и записано в базовом классе Animal.

    // Всё дело в том, что функция voice не была объявлена как виртуальная!
    // Но об этом - в следующий раз.
}

