// В прошлый раз в конце лекции мы рассматривали класс C,
// в котором по требованиям должны быть два поля, хранящие указатели на A и B:

class A;
class B;

class C {
private:
    A * a;
    B * b;
};

// При этом класс C должен владеть этими объектами типа A и B.
// То есть, в конструкторе он должен их создавать, в деструкторе - уничтожать.
// При копировании и присваивании должны делаться "глубокие" копии.

// Мы видели, что если работать с этими указателями непосредственно,
// то код получается небезопасным: из-за исключений при инициализации B
// ресурсы, выделенные для A могут утечь.
// Поэтому нам пришлось написать "лапшу" из обработчиков try-catch,
// чтобы предусмотреть такие случаи и предотвратить утечки.
// Это плохой C++.

// Правильным решением было бы использовать отдельную обёртку для каждого поля a и b,
// следуя идиоме RAII: захватывание ресурсов должно быть инициализацией объектов.

// Напишем для этого простую обёртку над одним отдельным указателем.
// Мы могли бы сделать такую обёртку отдельно для типа A и отдельно для типа B,
// но её сразу можно сделать шаблонной:

template <typename T>
class T_wrapper {
private:
    T * ptr;
public:
    T_wrapper(): ptr(new T) {}  // выделяем ресурс при инициализации

    T_wrapper(const T_wrapper& other):
    ptr(new T(*other.ptr))  // "глубокое" копирование
    {}

    T_wrapper& operator = (const T_wrapper& other) {
        *ptr = *other.ptr;  // понимаете, почему тут не нужен delete?
        return *this;
    }

    ~T_wrapper() {
        delete ptr;
    }

    const T * Get() const {  // наша обёртка будет притворяться обычным указателем - её можно так же разыменовывать
        return ptr;
    }

    T * Get() {
        return ptr;
    }
};

// Теперь класс C выглядит так:
class C {
private:
    T_wrapper<A> a;
    T_wrapper<B> b;
};

// Заметьте, никаких конструкторов, операторов присваивания и деструкторов в классе C теперь вообще писать не нужно!

// Что, например, произойдёт, если в конструкторе по умолчанию при инициализации поля b произойдёт исключение?
// В этом случае будет скручиваться стек. Для уже проинициализированных полей (у нас это a) будут вызваны деструкторы.
// Но теперь тип a - это не "голый" указатель, а наша обёртка. В её деструкторе и будет освобождена память. Утечки не произойдёт.


// Лирическое отступление.
// А зачем, кстати, кому-то может понадобиться хранить в классе C не обычные поля, а указатели?
// Чем вот такой класс хуже?
class C {
private:
    A a;
    B b;
};

// Ответ: указатели могут понадобиться по разным причинам.
// 1. Например, объекты типа A и B тяжёлые, и поэтому их хочется создавать не на стеке (который ограничен), а в динамической памяти.
// 2. Или, может потребоваться отложенная инициализация. Возможно, мы не хотим сразу инициализировать a или b потому что это
// долго, или дорого, или у нас пока не хватает для этого данных. Если там будет указатель (изначально - нулевой),
// то создать объекты типов A и B можно будет и позже.


template <typename T>
class Matrix {
private:
    std::vector<std::vector<T>> data;
};


// Другое лирическое отступление.
// Проблема с двумя указателями в классе C может показаться надуманной.
// Но давайте заменим эти два указателя, например, на низкоуровневый двумерный массив.
// Попробуем написать конструктор класса "матрица", у которой внутри элементы храняться в таком массиве
// (а не в векторе векторов, как в прошлом модуле).
// Конечно, можно было бы все элементы матрицы записать в один большой последовательный массив длины m * n,
// но мы выберем реализацию с двумерным массивом.
// Он представляется "двойным указателем": фактически это массив указателей, ссылающихся на начала блоков чисел - строк матрицы.

// Сначала - наивная версия:
template <typename T>
class Matrix {
private:
    size_t m, n;
    T ** data;  // указатель на начало массива указателей на начала строк

public:
    Matrix(size_t rows, size_t columns)
    : m(rows)
    , n(columns)
    {
         data = new T* [rows];
         for (size_t i = 0; i != rows; ++i)
             data[i] = new T[columns];
    }

    ~Matrix() {
        for (size_t i = 0; i != rows; ++i)
            delete [] data[i];
        delete [] data;
    }
};

// Здесь есть такая же опасность, как и в классе C с двумя указателями.
// Только указателей теперь не два, а целый массив.
// Можно было бы везде в похожих местах вставить try-catch:

template <typename T>
class Matrix {
private:
    size_t m, n;
    T ** data;

public:
    Matrix(size_t rows, size_t columns)
    : m(rows)
    , n(columns)
    {
         data = new T* [rows];  // если сбой произойдёт здесь, то это не страшно: new является транзакцией
         for (size_t i = 0; i != rows; ++i) {
             try {
                 data[i] = new T[columns];
             } catch (...) {  // ловим любое исключение
                 for (size_t j = 0; j != i; ++j)  // если произошёл сбой при инициализации i-й строки,
                     delete [] data[j];           // то предыдущие строки надо корректно уничтожить,
                 delete [] data;                  // а также надо уничтожить сам массив строк
                 throw;  // частично обработанное исключение перекидываем дальше
             }
         }
    }

    ~Matrix() {
        for (size_t i = 0; i != rows; ++i)
            delete [] data[i];
        delete [] data;
    }
};

// Правильное решение здесь согласно RAII - использовать вместо голых указателей обёртки над строкой и массивом строк.
// Это и есть вектор векторов.


// В стандартной библиотеке C++ имеются готовые обёртки над указателями, владеющие ресурсом.
// Это так называемые "умные" указатели.
// Рассмотрим std::unique_ptr.

#include <iostream>
#include <memory>  // все умные указатели объявлены здесь

int main() {
    int * ptr1 = new int(17);  // обычный указатель
    std::cout << *ptr1 << "\n";
    delete ptr1;  // важно не забыть!
    
    std::unique_ptr<int> ptr2(new int(17));  // а это - "умный" указатель
    // Обратите внимание: мы передаём ему уже выделенную динамическую память (а его конструктор только запоминает этот указатель).

    std::cout << *ptr2 << "\n";  // он притворяется обычным указателем - у него перегружены соответствующие операторы
    // при этом он "владеет" ресурсом: память будет освобождена в его деструкторе
    // слово unique в названии подчёркивает, что это единственный владелец ресурса

    // такой указатель нельзя скопировать
    // (потому что тогда будет непонятно, кто будет владеть ресурсом и удалять его: исходный объект или копия?)
    auto ptr3 = ptr2;  // не скомпилируется!

}  // всё, руками звать delete не надо, выделенная память освободится при выходе из блока


// Хотя unique_ptr нельзя копировать, его можно возвращать из функции:

int * foo() {
    // ...
    return new int(123);  // странная функция: она неявно требует, что вызывающая сторона должна взять на себя владение ресурсом
}

std::unique_ptr<int> bar() {
    // ...
    return std::unique_ptr<int>(new int(123));  // OK: возвращаем умный указатель
}

#include <utility>

int main() {
    foo();  // Ой! Возвращаемое значение проигнорировано, память утекла!
    bar();  // а тут ничего страшного: деструктор временного объекта очистил память

    auto ptr4 = bar();  // присвоить временный объект новому умному указателю можно!
    // Так происходит потому, что у std::unique_ptr объявлен конструктор перемещения, принимающий
    // на вход ссылку на временный объект.

    // Кстати, можно обычный (именованный) объект принудительно привести к типу временного (к rvalue-ссылке),
    // и тогда его можно будет передать в конструктор:
    auto ptr5 = static_cast<std::unique_ptr<int>&&>(ptr4);  // так получится
    // Но так писать громоздко. То же самое можно сделать с помощью std::move:
    auto ptr6 = std::move(ptr5);  // std::move объявлен в заголовочном файле utility
    // Внимание! После этих манипуляций у ptr4 и ptr5 отобрано владение, в них хранится nullptr!

}


// Напишем возможную реализацию unique_ptr:
namespace mystd {
    template <typename T>
    class unique_ptr {
    private:
        T * ptr;
    public:
        // конструктор std::unique_ptr объявлен как explicit, чтобы предотвратить автоматические приведения типов
        explicit unique_ptr(T * src = nullptr): ptr(src) {}

        unique_ptr(const unique_ptr&) = delete;  // запрещаем копирование и присваивание
        void operator = (const unique_ptr&) = delete;

        // однако разрешаем "отобрать" владение у временного объекта (например, вернувшегося из функции):
        unique_ptr(unique_ptr&& tmp): ptr(tmp.ptr) {
            tmp.ptr = nullptr;  // временный объект всё равно вот-вот умрёт,
            // так что запишем в его ptr значение nullptr, чтобы его деструктор не удалил данные
        }

        unique_ptr& operator = (unique_ptr&& tmp) {  // аналогичный оператор присваивания для временных объектов
             delete ptr;  // старые данные надо сначала удалить,
             ptr = tmp.ptr;  // а потом надо забрать владение новыми данными
             tmp.ptr = nullptr;  // а сам временный объект скоро всё равно будет умирать
             return *this;
        }

        unique_ptr& operator = (T * src) {  // умному указателю можно переприсвоить и обычный указатель
            delete ptr;
            ptr = src;
            return *this;
        }

        ~unique_ptr() {
            delete ptr;
        }

        const T& operator * () const {
            return *ptr;
        }

        // Конечно, у std::unique_ptr есть и другие функции и операторы.
        // Ознакомьтесь с ними здесь: http://ru.cppreference.com/w/cpp/memory/unique_ptr
    };
}


// Другая разновидность умного указателя - умный указатель с подсчётом ссылок на объект.
// Это std::shared_ptr.
// Такой указатель уже можно копировать.
// При копировании увеличивается счётчик созданных копий, в деструкторе он уменьшается.
// Объект удаляется последним владельцем (когда счётчик дойдёт до нуля).

#include <memory>

int main() {
    std::shared_ptr<int> ptr1(new int(17));

    auto ptr2 = ptr1;  // копирование разрешено!

    std::shared_ptr<int> ptr3;
    ptr3 = ptr1;  // присваивание тоже разрешено!
}

// Классический случай применения таких умных указателей - реализация графа,
// где каждая вершина хранит вектор указателей на соседние вершины.
// При этом требуется, чтобы изолированных вершин в графе не было (если нет рёбер, то вершину надо убрать).
// Проще всего это сделать, используя для ссылок shared_ptr.

// Однако надо помнить, что счётчик ссылок - это дополнительные накладные расходы.
// Поэтому предпочитайте указатель std::unique_ptr указателю std::shared_ptr
// (а обычный объект на стеке - указателю std::unique_ptr).

// Подробнее здесь: http://en.cppreference.com/w/cpp/memory/shared_ptr

