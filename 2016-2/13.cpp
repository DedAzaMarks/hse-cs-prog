// Дополнение к предыдущей лекции: как "читать" типы, содержащие указатели и const?

T * ptr1;  // просто указатель
const T * ptr2;  // указатель на константу типа T
T const * ptr3;  // то же самое, что и выше (const и T коммутируют)
T * const ptr4;  // константный указатель на неконстанту типа T
const T *  const ptr5;  // константный указатель на константу типа T

// Если const стоит после звёздочки, то нельзя менять сам указатель.
// Если до звёздочки - то нельзя менять то, на что указывает указатель.


ptr2 = nullptr;  // OK
ptr4 = nullptr;  // ошибка!
*ptr3 = T(42);   // ошибка!
*ptr4 = T(42);   // OK

// Вспомним, как мы определили сигнатуру функции strcpy в прошлый раз:
void strcpy(
    char * dest,  // обычный указатель (содержимое dest будет меняться)
    const char * source  // указатель на константу (содержимое source не должно изменяться)
) {
// ...
}
// Мы тут могли бы навесить дополнительные const на сами указатели dest и source,
// но мы этого не делаем, поскольку в функцию попадают всё равно копии указателей,
// а мы их в процессе работы как раз меняем (сдвигаем вправо с помощью ++).

// Я помню, как долго отлаживал примерно такой баг:
void foo(int * ptr) {
   // ...
   ++ptr;  // мне надо было увеличить число, на которое ссылается ptr, но я забыл звёздочку
   // ...
}
// Если бы я поставил слово const перед ptr, но компилятор схватил бы меня за руку,
// и я бы всё написал правильно:
void foo(int * const ptr) {
    // ...
    ++*ptr;  // компилятор не даст увеличить ptr, ошибка легко находится
    // ...
}
// Поэтому есть рекомендация: используйте const, где это возможно и уместно.


// ==================


// Сегодня мы поговорим про идиому RAII (Resource aquitization is initialization).
// Переводится это как "выделение ресурса должно быть инициализацией".
// Идея в том, что если у нас есть какой-то ресурс (память, файл, мьютекс и т. д.),
// который надо обязательно "вернуть", когда он будет уже ненужен,
// то лучше всего запрашивать этот ресурс в конструкторе некоторого объекта,
// а освобождать - в деструкторе.

// Рассмотрим хрестоматийный пример ресурса: файл.
// Как работали с файлами в языке С?
// Работа с файлами осуществлялась через файловый дескриптор. Это был просто указатель на специальную структуру FILE:

#include <cstdio>

int main() {
    FILE * f = fopen("a.txt", "r");  // открываем файл a.txt для чтения и получаем его дескриптор
    if (f != nullptr) {  // если дескриптор не является нулевым указателем, то файл успешно окрыт
        char buf[100];
        fscanf(f, "%s", buf);  // считываем из файла текст в буфер (наивно предполагая, что 99 символов нам хватит)
        // ...
        fclose(f);  // закрываем файл
    } else {
        std::cout << "Ошибка при открытии файла!\n";
    }
}

// В куске кода, обозначенном многоточием, тоже может быть много аварийных ситуаций. 
// В каждой из них надо не забыть закрыть файл. Код с такими проверками становится очень громоздким.


// Следуя идиоме RAII, мы бы "обернули" файл в объект специального класса.
// Тогда открытие файла соответствовало бы инициализации объекта в его конструкторе,
// а закрытие файла - уничтожению объекта в деструкторе.

// В случае ошибки при открытии файла мы бы сгенерировали исключение, и объект нашего класса не был бы создан.

#include <exception>  // для std::exception
#include <string>

class CannotOpenFileException: std::exception {
};

class File {
private:
    FILE * f;  // тот самый файловый дескриптор, который мы оборачиваем

public:
    File(const char * name) {
        f = fopen(name, "r");
        if (f == nullptr)
            throw CannotOpenFileException();  // генерировать исключения в конструкторах - это нормально!
    }

    ~File() {
        if (f != nullptr)
            fclose(f);
    }

    std::string Read() const {
        char buf[100];
        fscanf(f, "%s", buf);
        return buf;
    }
};


// Теперь можно работать так:
int main() {
    try {
        File f("a.txt");
        const auto& str = f.Read();
        // ...
    } catch (const CannotOpenFileException&) {
        std::cout << "Ошибка при открытии файла!\n";
    }
}

// Что бы ни произошло в строках с многоточием, для объекта f всегда будет вызван деструктор, а значит, файл будет корректно закрыт.


// Правда, нас пока подстерегают проблемы с копированием и присваиванием:

File f1("a.txt");
File f2 = f1;  // конструктор копирования
File f3("b.txt");
f3 = f1;  // оператор присваивания

// Все три этих объекта хранят на самом деле один и тот же файловый дескриптор.
// Когда для них вызовутся деструкторы, то один и тот же файл будет закрыт несколько раз, что ошибочно.
// Возможно, тут будет разумным просто запретить такое копирование и присваивание.
// Это можно сделать хотя бы так:

class File {
    File(const File&) = delete;  // запрещаем компилятору автоматически генерировать конструктор копирования
    File& operator = (const File&) = delete;  // и оператор присваивания
    // ...
};


// Но всё-таки хочется, чтобы вот такой код был допустимым:

File GetFile() {
    return File("a.txt");
}

int main() {
     File f = GetFile();  // сейчас не сработает - конструктор копирования запрещён!
     // ...
}

// В отличие от предыдущего примера с копированием, здесь копируется временный объект - результат функции GetFile.
// Для таких объектов в C++11 предусмотрены особые rvalue-ссылки.
// Можно просто написать конструктор перемещения, который заберет данные из такого объекта:

class File {
    File(const File&) = delete;  // запрещаем компилятору автоматически генерировать конструктор копирования
    File& operator = (const File&) = delete;  // и оператор присваивания

    File(File&& other) {  // File&& - ссылка на временный объект
        f = other.f;
        other.f = nullptr;  // забираем владение дескриптором у временного объекта
    }

    File& operator = (File&& other) {
        if (f != nullptr)
            fclose(f);
        f = other.f;
        other.f = nullptr;
        return *this;
    }

    // ...
};


// В стандартной библиотеке уже есть готовая обёртка над файловыми дескрипторами std::fstream,
// позволяющая работать с файлами как с потоками ввода-вывода. Пользуйтесь ей.

// Вообще, все контейнеры стандартной библиотеки (std::vector, std::string и т. д.)
// так или иначе исповедуют идиому RAII: в их конструкторах выделяется память,
// которой они владеют, а в деструкторах эта память освобождается, что бы ни произошло.


// ==================

// Рассмотрим задачку, которую часто предлагают на собеседованиях.
// Сначала простой вариант.

// Это некий вспомогательный класс.
class A {
};

// Нужно написать конструкторы и деструктор класса C, владеющего переменной типа A в динамической памяти.
// Напишем сначала наивный вариант.
class C {
private:
    A * x;

public:
    C(): x(new A) {
    }

    // ...

    ~C() {
        delete x;
    }
};

// Тут есть такая же проблема, как и с классом File:
// конструктор копирования и оператор присваивания по умолчанию просто скопируют указатель на ту же память:

int main() {
    C c1;
    C c2(c1);
}  // проблема: в деструкторе c1 память будет освобождена дважды!

// Допишем конструктор копирования и оператор присваивания.
// В отличие от класса File мы не будем их запрещать, а сделаем "глубокое" копирование:
class C {
private:
    A * x;

public:
    C(): x(new A) {
    }

    C(const C& other): x(new A(*other.x)) {  // создаём новый объект с помощью конструктора копирования класса A
    }

    C& operator = (const C& other) {
        *x = *other.x;  // разберитесь-ка, всё ли тут в порядке?
        return *this;
    }

    ~C() {
        delete x;
    }
};

// Это была простая задача. Теперь усложним её.
// Пусть есть два (каких-то) класса: A и B.
// А в нашем классе C должны быть два указателя: и на A, и на B.
// И наш класс должен владеть и той, и другой динамической памятью.

class A {
   // ...
};

class B {
   // ...
};

class C {
private:
    A * x;
    B * y;

public:
    C(): x(new A), y(new B) {
    }
    
    C(const C& other): x(new A(*other.x)), y(new B(*other.y)) {
    }

    C& operator = (const C& other) {
        *x = *other.x;
        *y = *other.y;
        return *this;
    }

    ~C() {
        delete x;
        delete y;
    }
};

// Казалось бы, в чём подвох.
// Однако такой класс является опасным.

// Дело в том, что в конструкторе при инициализации поля y может произойти ошибка!
// Во-первых, может просто не хватить динамической памяти.
// Во-вторых, может произойти исключение в конструкторе класса B.
// Сама ошибка не является чем-то опасным. Однако давайте посмотрим, что произойдёт при этом с полем x.
// При исключении будет сворачиваться стек. В частности, будет вызван деструктор для уже проинициализированной переменной x.
// Но деструктор указателя тривиален. Этот деструктор не сделает ничего.
// Поэтому а) объект *x не будет корректно уничтожен и б) память в x "утечёт".
// (Заметим, что деструктор самого С вызван не будет, так как конструтор завершился с ошибкой.)

// Первое приходящее в голову решение: обернуть инициализацию в конструкторе в try/catch:


class C {
private:
    A * x;
    B * y;

public:
    C() {  // можно писать обёртки try/cath и поверх инициализации полей, но не будем ничего усложнять и заменим инициализацию присваиванием:
       x = new A;  // тут тоже может произойти ошибка, но она не приведёт к утечкам
       try {
           y = new B;
       } catch (...) {
           delete x;  // если что-то пошло не так, то освобождаем уже созданный x и прокидываем исключение дальше
           throw;
       }
    }

    // Примерно те же макароны надо будет написать в конструкторе копирования и в операторе присваивания
    // ...

    ~C() {
        delete x;
        delete y;
    }
};

// Мы решили проблему, но это выглядит немного коряво.
// Если ли лучшее решение?
// Следуя идиоме RAII нам надо было бы каждую переменную (и x, и y) вместо обычного указателя
// хранить в какой-нибудь умной "обёртке" (специальном классе),
// такой, что в конструкторе этой обертки выделяется память, а в деструкторе - освобождается.
// (В чём-то такая обёртка была бы похожа на предыдущую версию класса C с одним указателем.)
// Тогда в самом классе C нам не пришлось бы обрабатывать исключения и даже не надо было бы писать деструктор.
// Более того, не надо было бы вообще определять свои методы: сгодились бы все те, что компилятор предоставляет по умолчанию.

// Умные обёртки над отдельным указателем, следующие идиоме RAII, есть в стандартной библиотеке.
// Это так называемые "умные указатели". Но о них мы поговорим в следующий раз.

