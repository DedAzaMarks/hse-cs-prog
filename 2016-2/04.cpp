// Познакомимся с "ассоциативными массивами" - контейнерами, ключом в которых служит не целочисленный индекс,
// а произвольный объект заданного типа.
// Начнём с контейнера map.

#include <map>
#include <string>

int main() {
    // Контейнер map: внутри - красно-чёрное дерево.
    // Сложность операций поиска, вставки и удаления логарифмическая.
    map<string, int> data;  // на ключах должен быть определен оператор <

    data.insert("hello", 1);  // вставили значение
    data.insert("hello", 42);  // перезаписали значение, ассоциированное с ключом hello

    data["hell"];  // внезапно: не нашли такого ключа, поэтому на лету вставили его со значением по умолчанию (0)

    data["hello"] += 1;
    data["good bye"] = 100;

    auto it = data.find("hell");  // проверяем, есть ли такой ключ
    if (it == data.end()) {  // если его нет, то возвращаемый итератор совпадает с data.end()
        cout << "Not found!\n";
        return 0;
    }
    // в противном случае итератор можно "разыменовать", обратившись к найденной паре (ключ, значение)
    cout << "Found: " << it->first
         << "\t" 
         << it->second 
         << "\n";

    for (const auto& elem : data) {  // все элементы выводятся в отсортированном по ключам порядке
        cout << elem.first 
             << "\t"
             << elem.second
             << "\n";
    }
}


// Типичная задача - подсчитать частоты разных символов в строке
#include <iostream>
#include <map>
#include <string>

using namespace std;

int main() {
    string word;
    map<string, int> freqs;
    while (cin >> word)
        ++freq[word];  // если ключа не было - он вставится на лету со значением 0

    for (const auto& kv : freqs)  // kv - от слов key and value
        cout << kv.first << "\t" << kv.second << "\n";
}

// Такая программа выдаст список слов с их частотами, упорядоченный по ключам (по алфавиту)

// Попробуем теперь сделать так, чтобы список выдавался по убыванию частоты слова
// Для этого скопируем в конце элементы в вектор и отсортируем его с помощью своей функции сравнения.

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

// Функция для сравнения элементов при сортировке.
// Она должна вернуть true, если элемент a должен идти в отсортированном массиве раньше b.
bool compare(const pair<string, int>& a, const pair<string, int>& b) {
    return (a.second > b.second) || (a.second == b.second && a.first < b.first);
}

int main() {
    string word;
    map<string, int> freqs;
    while (cin >> word)
        ++freq[word];  // если ключа не было - он вставится на лету со значением 0

    for (const auto& kv : freqs)  // kv - от слов key and value
        cout << kv.first << "\t" << kv.second << "\n";

    // Пары изначально отсортированы по символам
    // Копируем пары в вектор, чтоб затем отсортировать их по частотам
    vector<pair<char, int>> items(  // конструкторы стандартных контейнеров умеют инициализироваться парой итераторов
        freq.begin(),
        freq.end()
    );

    sort(items.begin(), items.end(), compare);  // сортируем вектор с указанием нашей функции сравнения

    for (const auto& kv : items)
        cout << kv.first << "\t" << kv.second << "\n";
}

// Другие похожие контейнеры - это
// -- std::unordered_map (хеш-таблица, средняя сложность операций O(1));
// -- std::multimap (мультиассоциативный массив, разрешается иметь много значений при ключах);
// -- std::set (множество: считайте, что это map с проигнорированными значениями);
// -- std::multiset (мультимножество)
// -- std::unordered_multimap (мульти-хеш-таблица);
// -- std::unordered_set (хеш-множество);
// -- std::unordered_multiset (мульти-хеш-множество).

// Сравним std::map и std::unordered_map:
// 1. map использует внутри сбалансированное дерево, unordered_map - хеш-таблицу.
// 2. Сложность операций поиска, вставки и удаления элементов для map логарифмическая, для unordered_map - константная.
// 3. map требует, чтобы ключи были сравнимы (по умолчанию - с помощью оператора <).
// Для unordered_map требуется, чтобы на ключах была определена хеш-функция.
// 4. Элементы map'а перебираются в отсортированном порядке, а в unordered_map - в зависимости от значений хеша.

