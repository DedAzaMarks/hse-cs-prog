// В прошлый раз мы не успели поговорить про векторы векторов (матрицы, таблицы)
// Напишем простую программу, которая сначала узнаёт число строк и столбцов,
// считывает числа в матрицу, а затем красиво печатает её на экране

// Один из вариантов может быть таким:

#include <iostream>
#include <vector>

int main() {
    size_t rows, columns;
    std::cin >> rows >> columns;
    std::vector<std::vector<int>> table(
        rows,  // передаём в конструктор сразу число элементов внешнего вектора (у нас будет rows строк)
        std::vector<int>(columns)  // и образец, по которому будут созданы эти элементы (вектор из columns нулей)
    );
    for (size_t i = 0; i != rows; ++i) {
        for (size_t j = 0; j != columns; ++j)
            std::cin >> table[i][j];
    }
    // ...

    for (size_t i = 0; i != table.size(); ++i) {
        for (size_t j = 0; j != table[i].size(); ++j)
            std::cout << table[i][j] << "\t";
        std::cout << "\n";
    }
}

// Другой вариант считывания данных может быть таким:
int main() {
    size_t rows, columns;
    std::cin >> rows >> columns;
    std::vector<std::vector<int>> table;
    table.reserve(rows);  // резервируем место под rows строк, но пока не создаём их
    for (size_t i = 0; i != rows; ++i) {
        table.push_back(std::vector<int>());  // кладём во внешний вектор очередную (пока пустую) строку
        table.back().reserve(columns);  // резервируем место под columns элементов
        for (size_t j = 0; j != columns; ++j) {
            int x;
            std::cin >> x;
            table.push_back(x);
        }
    }
}

// ------------------

// Лирическое отступление: сколько памяти занимает вектор на стеке?

#include <iostream>
#include <vector>

int main() {
    std::vector<int> v;
    std::cout << sizeof(v) << "\n";  // что тут будет напечатано?

    v.resize(1000000);
    std::cout << sizeof(v) << "\n";  // а тут?
}

// На самом деле sizeof(v) (то есть, размер данной локальной переменной на стеке) никак не зависит от числа элементов в контейнере
// и вообще должен быть известен на момент компиляции

// В данном случае оба числа будут равны 24 (размер может отличаться на разных платформах).
// Ведь вектор - это всего лишь лёгкая обёртка, в которой хранится указатель на начальный адрес памяти,
// а также размеры занятой и зарезервированной области (или указатели на концы памяти).
// Сами же элементы хранятся не на стеке, а в динамической памяти.


// ------------------

// Сегодня мы поговорим про функции.

// Напишем простейшую функцию, находящую сумму двух целых чисел:
int sum(int a, int b) {  // в заголовке функции указывается тип возвращаемого значения и типы аргументов
    return a + b;
}

// Если функция ничего не должна возвращать, её можно объявить как void:
void do_something(double d, char c) {
   // ...
}


int main() {
    int x = 17, y = 42;
    int z = sum(x, y);
    do_something(3.14, '@');
}


// Классический пример - функция power, вычисляющая a^n.
// Вы уже писали такую на Python'е.
// Линейный вариант:
int power(int a, unsigned int n) {
    int result = 1;
    while (n != 0) {
        result *= a;
        --n;  // параметры можно смело изменять - здесь это копии, в вызывающем коде этого не будет видно
    }
    return result;
}

// Быстрое возведение в степень
int power2(int a, unsigned int n) {
    int result = 1;
    while (n != 0) {
        // Инвариант: result * a^n == const
        if (n % 2 == 0) {
            a *= a;
            n /= 2;
        } else {
            result *= a;
            --n;
        }
    }
    return result;
}


// Другой пример - факториал:
unsigned int factorial(unsigned int n) {
    if (n == 0)
        return 1;
    return n * factorial(n - 1);  // вызываем себя рекурсивно
}

// Помните, что если делать очень много рекурсивных вызовов, то рано или поздно переполнится стек
// (область памяти, в которой хранятся аргументы и локальные переменные текущей функции)


// ------------------

// Теперь поговорим о ссылках
// Ссылки - это просто псевдонимы для уже существующих объектов.

#include <iostream>
#include <string>
#include <vector>

int main() {
    int a = 17;
    std::vector<std::string> s{"hello", "world"};

    int& b = a;  // b - это не новая переменная, а ссылка на a. Можно считать, что это псевдоним для a.

    ++b;  // обращаемся через имя b, но увеличиваем на самом деле a (другой-то переменной тут и нет)

    std::cout << a << "\n";  // будет 18

    std::vector<std::string>& t = s;  // ссылка на s
    std::cout << t.size() << "\n";  // напечатает 2
}


// Посмотрим, как будут вести себя ссылки применительно к аргументам функции.
// Попробуем написать функцию, меняющую местами два своих аргумента:

#include <iostream>

int swap(int a, int b) {
    int c = a;
    a = b;
    b = c;
    std::cout << "In swap: " << a << " " << b << "\n";  // отладочная печать
}

int main() {
    int x = 17, y = 42;
    swap(x, y);
    std::cout << x << " " << y << "\n";
}

// Увы, так ничего не работат:
// In swap: 42 17
// 17 42

// То есть, внутри функции swap а и b поменялись, но в функции main этого не видно.
// Всё потому, что по умолчанию аргументы в функцию передаются "по значению".
// Это значит, что функция работает с копиями исходных переданных значений.
// Поэтому изменение этих копий не видно на вызывающей стороне.


// Теперь сделаем так, чтобы аргументы передавались "по ссылке":
int swap(int& a, int& b) {
    // ...
}

// В результате всё заработает, как ожидается.
// Мы здесь при входе в функцию скопировали не сами значения x и y, а ссылки на них.
// Эти ссылки ссылаются на те же места в памяти, где лежат исходные x и y.


// Обратите внимание, что в случае передачи аргументов по ссылке мы уже не сможем вызвать функцию вот так:
int main() {
    swap(1, 2);  // не скомпилируется: ссылку можно привязать лишь к сущности, у которой есть адрес в памяти (к переменной)
}


// ------------------

// Наш следующий сюжет - константность
int main() {
    int x;
    std::cin >> x;
    const int y = x * 42;  // Константа. Компилятор проверит, что мы её нигде не изменяем.
    constexpr double g = 9.81;  // Константа, известная во время компиляции. Компилятор может использовать это знание для оптимизации.
}

// Ссылки тоже могут быть константными:
int main() {
    int x = 42;
    const int& ref = x;  // OK: через имя ref можно только читать значение, но нельзя изменить

    std::cout << ref;  // выведет 42

    x = 0;  // OK: через имя x значение менять можно

    ref = 1; // А вот это - ошибка компиляции

    const int y = 17;
    int& ref2 = y;  // Ошибка! К константе можно привязать только константную ссылку!
    const int& ref3 = y;  // OK
}


// ------------------

// Константные ссылки в аргументах функций

// Иногда копирование объекта может быть очень дорогим (и ненужным).
// Например, копирование вектора приведет к копированию всех его элементов.

// Поэтому вот так передавать вектор в функцию неэффективно:
void f(std::vector<int> v) {
    // Плохо: при вызове функции создаётся копия вектора
}

// Копии можно было бы избежать, если бы вектор передавался по ссылке:
void f(std::vector<int>& v) {
    // Но теперь есть другие недостатки:
    // 1. В такую функцию нельзя передать константный вектор.
    // 2. Функция не защищена от случайного изменения вектора:
    v.clear();  // тут компилятор нас не схватит за руку
}

// Поэтому самое правильное - передавать такой параметр по константной ссылке:
void f(const std::vector<int>& v) {
    // Такой аргумент не требует дорогого копирования, его нельзя случайно изменить внутри, и такую функцию можно вызывать от констант!
}

// Давайте запомним:
// Аргументы сложных типов (векторы, строки, любые контейнеры, большие структуры) ВСЕГДА старайтесь передавать в функцию по константной ссылке.
// (Бывают исключения из этого правила, но мы о них поговорим отдельно.)

// Только не надо это правило распространять на обычные встроенные типы:

void g(const int& a, const char& c) {  // Так делать не надо! Это уже перебор!
    // передавайте такие параметры просто по значению, как int или char
}

