// Сегодня мы поговорим о структурах, а также о стеке и динамической памяти
// Структура в первом приближении - это созданный пользователем тип данных, 
// объединяющий несколько переменных (полей) "под одной крышей"
// В C++ структуры и классы почти ничем не отличаются
// (все члены структур по умолчанию открыты, а в классе - закрыты).
// Но мы будем использовать слово "структура", когда не будем хотеть от этого типа ничего другого,
// кроме объединения полей. 
// Мы не будем определять функции-члены структуры, писать конструкторы и деструкторы, перегружать операторы и т. д.
// Всё это мы, конечно, будем проходить, но чуть позже. И будем говорить тогда не "структура", а "класс".
// А сейчас "структура" для нас - это POD (plain old data, "старые добрые данные") - есть такой термин в C++-жаргоне.

#include <string>
#include <vector>
#include <iostream>

// Дата задаётся днем, месяцем и годом.
// По отдельности эти величины таскать неудобно. Объединим их в структуру.
struct Date {
    int Day;
    int Month;
    int Year;
}; // обратите внимание на эту точку с запятой, она нужна.

// Студент, например, описывается именем и фамилией, датой рождения, годом поступления и рейтингом.
struct Student {
    std::string Name;
    std::string Surname;
    Date Birthday; // тип этого поля - структура, определенная выше
    int Year;
    double Rating;
};

int main() {
    Date d1 {23, 10, 2015}; // инициализируем поля структуры в порядке их объявления

    Date d2;
    d2.Day = 23; // Но можно было бы присвоить им значения и вот так
    d2.Month = 10;
    d2.Year = 2015;

    Student s { // описываем студента
        "Ivan",
        "Ivanov",
        d1, // это его дата рождения 
        2015,
        10.0
    };

    // Допустим, надо считать данные о студентах с клавиатуры. Сделаем примерно так
    size_t N;
    std::cin >> N; // узнаём, сколько будет студентов
    std::vector<Student> students(N); // создаём вектор "пустых" студентов размера N
    for (auto& s : students) { // можно было бы написать Student& вместо auto&. Благодаря ссылке значение s можно изменять.
        std::cin >> s.Name >> s.Surname; // считываем фамилию и имя очередного студента
    }
    const auto& x = students.back(); // берём последнего студента с помощью константной ссылки
    // (можно было бы написать const Student& вместо const auto&)
    // Если бы мы написали вот так
    Student у = students.back(); // или auto у = students.back()
    // то x было бы "копией" элемента вектора. А лишнее копирование большой структуры нам ни к чему.

    // Как отсортировать студентов? Для этого надо научиться их попарно сравнивать.
    // Можно определить функцию, ведущую себя как оператор "меньше", и сравнивающую двух студентов:
    bool less(const Student& a, const Student& b) {
        if (a.Rating != b.Rating)
            return a.Rating > b.Rating; // сравниваем сначала по рейтингу (в порядке убывания)
        else
            return a.Surname < b.Surname; // затем - по фамилии
    }
    
    // отсортировать теперь можно так:
    #include <algorithm> // надо подключить этот заголовок вверху
    // ...
    std::sort(students.begin(), students.end(), less);

    // Обратите внимание, мы передавали параметры в функцию less по константной ссылке.
    // Можно было бы написать
    bool less(Student a, Student b);
    // но тогда бы происходило лишнее копирование параметров при каждом входе в функцию.
    // Копировать объект типа Student - дорого.
    // Во-первых, он содержит строки, копирование которых повлечет новое выделение памяти.
    // Во-вторых, он сам по себе занимает много места (больше, чем ссылка).

    // Хороший вопрос на понимание: а что выведет sizeof(s)? А sizeof(students)?
    std::cout << sizeof(s) << "\n";
    // В зависимости от платформы и компилятора результат может быть разным. У меня (Ubuntu, x86_64, g++ 4.8.4) это 40.
    // (Кстати, результат будет таким же и для sizeof(Student), то есть, он зависит только от типа.)
    // Давайте разберемся, почему.
  
    std::cout << sizeof(s.Name) << "\n";     // 8
    std::cout << sizeof(s.Surname) << "\n";  // 8
    std::cout << sizeof(s.Birthday) << "\n"; // 12
    std::cout << sizeof(s.Year) << "\n";     // 4 
    std::cout << sizeof(s.Rating) << "\n";   // 8

    // Тип int на моем компьютере занимает 4 байта памяти, а double - 8.
    // Отсюда понятно, почему Date тогда занимает 12 байт.
    
    // Разберемся теперь со строками.

    // В С++, грубо говоря, есть два типа памяти (на самом деле больше, но сейчас это не важно): стек и динамическая память (или куча).

    // 1. Стек - это память, в которой хранятся параметры текущей функции и ее локальные переменные.
    // Когда мы пишем что-то вроде
    int a;
    // то мы выделяем память под эту переменную на стеке.
    // Такая переменная "живет" до ближайшей закрывающей фигурной скобки. Действительно я могу написать
    {
        double b;
        {
            char c;
        } // здесь "умирает" c
    } // здесь "умирает" b

    // Поэтому переменная, объявленная последней, умрёт первой. Структура данных "стек" как раз так и работает: last in - first out.
    // Можно считать, что для стека операционной системой выделяется большой фрагмент памяти, в котором есть невидимая перегородка
    // между занятой и незанятой областью. Когда надо выделить или удалить память, эта перегородка просто сдвигается.
    //
    // Кстати, чем опасна бесконечная рекурсия? Стек, в котором хранится также последовательность вызываемых функций, может переполнится.
    // Отсюда происходит название популярного сайта: stackoverflow.com

    // 2. Другой вид памяти - динамическая память (или куча).
    // Здесь программист сам явно просит операционную систему выделить блок байтов заданного объема.
    // Но он же должен и вернуть его системе, когда память не нужна (иначе она "утечёт").
    // Это делается примерно так:

    int * p = new int;  // попросить у операционной системы блок памяти под хранение одной переменной типа int; проинициализировать эту память нулём.
    // p - это "указатель на int", который ссылается на память:
    std::cout << *p << "\n"; // выведет 0
    *p = 42; // изменит значение
    // когда память станет не нужна, ее надо освободить:
    delete p;

    // Точно так же можно выделять память под массив:
    {
        int arr1[42]; // статический массив (выделенный на стеке) из 42 элементов типа int
        int * arr2 = new int[42]; // динамический массив из 42 элементов типа int
        // указатель arr2 указывает на начальный элемент выделенного блока
        arr1[3] = 17;
        arr2[5] = -1; // такая запись просто эквивалентна *(arr2 + 5) = -1
        int * ptr = arr1 + 3; // можем запросто сдвинуться, чтобы указатель ptr указывал на 4-й элемент массива arr1
        ptr = &arr1[3]; // или вот так
    } // здесь автоматически "умирает" arr1
    delete [] arr2; // а вот память, выделенная под arr2, освободится только тогда, когда мы явно об этом попросим

    // Обратите внимание: если память выделялась с помощью new, то освобождать её следует с помощью delete.
    // А если выделялась с помощью new[], то освобождать нужно с помощью delete[].
    // И отдельный элемент, и массив в динамической памяти представляются указателем.
    // И сам компилятор не может разобраться, на что данный указатель сейчас указывает: на начало массива или на отдельный элемент.

    // Вернёмся к нашему вопросу про sizeof(s).
    // Надо понять, как в первом приближении внутри устроена строка (std::string) или вектор.
    // Эти классы стандартной библиотеки выделяют внутри динамическую память для хранения элементов.
    // Можно мысленно представить, что вектор целых чисел в очень грубом приближении устроен как-то так:
    struct Vector {
        int * start; // начало выделенного блока памяти для хранения данных
        size_t size; // размер заполненной области
        size_t reserved; // размер зарезервированной области
    };
    // И тогда sizeof(vector) = 24 (столько байт он занимает на стеке), хотя в реальности выделяется еще и динамическая память.
    
    // Аналогично, строка внутри может содержать какой-то указатель на динамическую память.
    // И поэтому на стеке она занимает 8 байт, хотя в реальности выделяется еще и динамическая память.
}   

// Подытожим.
// Всегда, если не требуется что-то особое, старайтесь вместо массивов использовать std::vector, а для строк - std::string.
// Однако, нужно знать, как устроены массивы в C++, и как работать с динамической памятью.

