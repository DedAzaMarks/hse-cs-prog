// (Вопрос с предыдущей лекции.)
// Всё ли в порядке с этим кодом?

#include <vector>

int main() {
    std::vector<int> v = {1, 2, 3, 4};
    auto iter = v.begin();
    // ...
    v.push_back(5);
    std::cout << *iter << "\n";  // Тут будет проблема!
}

// Проблема тут вот в чём: после выполнения операции push_back в векторе, вообще говоря,
// может произойти реаллокация.
// После этого все итераторы (и указатели) на элементы вектора станут невалидными.
// То есть, они будут ссылаться на память, которая вектору уже не принадлежит.
// Попытка обращения к этой памяти приводит к неопределённому поведению программы.


// Мы говорили с вам о контейнере map.
// Давайте разберёмся теперь с контейнером set (множество).
// В каком-то смысле set проще, чем map: можно считать, что set - это map, но без значений.
// Как и map, set основан на структуре данных "красно-чёрное дерево".
// Он позволяет за логарифмическое время искать, вставлять и удалять элементы.
// Важное требование - для элементов должен быть определён оператор <.

// Следующая программа считывает числа и выводит их без повторений в отсортированном порядке:
#include <iostream>
#include <set>

int main() {
    std::set<int> numbers;
    int x;
    while (std::cin >> x)
        numbers.insert(x);  // вставляем элемент
    for (int elem : numbers)  // элементы в set'е перебираются в отсортированном порядке
        std::cout << elem << " ";
    std::cout << "\n";
}

// Вопрос из зала: как искать или удалять элемент?

auto iter = numbers.find(3); // ищем тройку, получаем итератор
if (iter != numbers.end()) // если элемент не найден, то вернётся итератор end
    std::cout << "Found!\n";
else
    std::cout << "Not found!\n";

numbers.erase(iter); // удаляем элемент по итератору
// итератор в этом случае должен быть валидным (например, не должен быть равен numbers.end())

// Вопрос из зала: как очистить контейнер?
// Ответ: всякий стандартный контейнер имеет функцию clear:
numbers.clear();


// Есть альтернативная пара контейнеров, основанных на хеш-таблице (как dict в python'e):
// unordered_map и unordered_set.
// Операции вставки, поиска и удаления элемента в этих контейнерах выполняются за O(1),
// но перебрать элементы в отсортированном порядке уже не получится (отсюда и название).
// Здесь требование к типу элементов - для него должна быть определена хеш-функция.

// Работать с ним можно точно так же:

#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> numbers;
    int x;
    while (std::cin >> x)
        numbers.insert(x);
    for (int elem : numbers)  // порядок перебора элементов определяется хеш-функцией
        std::cout << elem << " ";
    std::cout << "\n";
}


// Вопрос из зала про цикл for по контейнеру.
// На самом деле это всего лишь "синтаксический сахар", который разворачивается компилятором примерно так:
for (auto iter = numbers.begin(); iter != numbers.end(); ++iter) {
    int elem = *iter;
    std::cout << elem << " ";
}


// Вопрос из зала: у всех ли контейнеров есть встроенная функция find?
// Ответ: нет. Она есть только у тех контейнеров, где найти элемент можно,
// вообще говоря, быстрее, чем полным перебором всех элементов. 
// Например, она есть у map, set, unordered_map, unordered_set.
// Ещё она есть у string и используется там для поиска подстроки.

// Но у таких контейнеров, как vector, deque, list такой встроенной функции нет.
// Вместо этого предлагается воспользоваться общим алгоритмом find,
// который реализован как внешняя шаблонная функция в заголовочном файле algorithm:

#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    auto iter = std::find(v.begin(), v.end(), 3);  // ищем тройку
    if (iter != v.end())
        std::cout << "Found\n";
    else
        std::cout << "Not found\n";
}

// Конечно, можно было бы применять find не ко всему вектору, а лишь к некоторому поддиапазону:
auto iter = std::find(v.begin() + 2, v.end(), 3); // начинаем поиск с третьего элемента массива
// Только надо быть уверенным, что v.begin() + 2 - законный итератор
// (то есть, он либо находится "внутри" вектора, либо совпадает с v.end()).

// Вопрос из зала: а можно аналогично вычитать что-то из v.end()?
// Ответ: да, можно, но с тем же условием: вы должны быть уверены, что полученный итератор - законный.

// Кстати, обратите внимание, что вот такой код с std::list уже бы не заработал:
std::list<int> l = {1, 2, 3, 4, 5};
auto iter = std::find(l.begin() + 2, l.end(), 3);

// Знаете, почему?
// Потому что для итераторов двусвязного списка не определен сдвиг на произвольное целое число.
// То есть, l.begin() + 2 просто не может скомпилироваться.
// Действительно, для двусвязного списка, в отличие от вектора, операция сдвига на произвольное число ячеек
// не может быть выполнена эффективно (за константное время). Поэтому она и не реализована.
// Мы могли бы выкрутиться тут так:
std::list<int> l = {1, 2, 3, 4, 5};
auto start = v.begin();
++++start;  // для итераторов двусвязного списка определен лишь сдвиг к соседним элементам с помощью ++ и --
auto iter = std::find(start, l.end(), 3);


// Тот же самый алгоритм find можно было бы применить и к обычному массиву:
int a[] = {1, 2, 3, 4, 5};
const int * pointer = std::find(a, a + 5, 3);  // в данном случае итератором является просто указатель


// std::find можно применить и ко множеству (set), но встроенная функция find будет работать асимптотически быстрее
// (за O(ln n), а не O(n).


// Как же устроен std::find внутри?

// Для этого нам надо изучить шаблонные функции.
// Предположим, что мы пишем функцию "максимум":
int max(int a, int b) {
    if (a > b)
        return a;
    else
        return b;
}

// Но применить такую функцию к аргументам типа double не получится
// (точнее, получится, но работать мы будем с округленными значениями типа int).
// Можно было бы написать отдельный "перегруженный" вариант этой функции для double:
double max(double a, double b) {
    if (a > b)
        return a;
    else
        return b;
}

// "Перегрузка функции" - это когда мы определяем несколько функций с одинаковыми именами,
// но с разными наборами (и/или типами) параметров.
// Компилятор при вызове такой функции пытается сам определить по типам параметров,
// какой из её вариантов подходит.

// Но перегрузить функцию max для всех типов - не самое лучшее решение.
// Ведь тело такой функции вообще не меняется, а меняются только типы в её заголовке.
// Можно написать шаблон функции, чтобы функции max для разных типов данных создавались по единому образцу:

template <typename T>  // ещё можно писать class T, но я предпочитаю так
T max(T a, T b) {
    if (a > b)
        return a;
    else
        return b;
}

// Важно подчеркнуть, что это пока не функция, а шаблон.
// Когда мы вызовем эту функцию с параметрами типа int,
// компилятор сгенерирует по этому шаблону функцию int max(int, int).
// Когда вызовем с параметрами типа double - компилятор сгенерирует по образцу функцию double max(double, double).

// Функции заголовочного файла algorithm стандартной библиотеки тоже шаблонные.
// Они принимают на вход итераторы произвольного (неизвестного заранее) типа.
// Вот как могла бы быть написана функция find:

template <typename Iter, typename Value>
Iter find(Iter first, Iter last, Value value) {
    while (first != last) {
        if (*first == value)
            return first;
        ++first;
    }
    return last;
}

// Здесь от объектов типа Iter требуется лишь то, чтобы они умели сравниваться (!=),
// разыменовываться (*first) и сдвигаться к следующему элементу (++).

// Вообще, идея стандартной библиотеки в том,
// что вместо того, чтобы описывать для каждого из M различных контейнеров
// N разных алгоритмов,
// достаточно описать каждый из алгоритмов один раз, но в шаблонном виде.
// А итераторы - это абстракция, которая позволяет отвлечься 
// от физического хранения элементов в памяти контейнера
// и рассматривать лишь их логический порядок.


// Вот ещё несколько примеров функций из заголовочного файла algorithm.

#include <algorithm>
#include <list>
#include <vector>

int main() {
    std::vector<int> v = {1, 2, 3};
    std::list<int> l = {4, 5, 6, 7, 8, 9};
    // ...
    // Копируем содержимое вектора в список, начиная с его начала
    std::copy(v.begin(), v.end(), l.begin());
    // В контейнере, в который копируем (здесь - в списке l)
    // должно быть выделено достаточно места.
    // В результате v не изменится, а l будет таким: 1, 2, 3, 7, 8, 9.
}

// Как вы думаете, что возвращает функция copy?
// Правильный ответ - итератор, указывающий за последний скопированный элемент второго контейнера.
// В нашем примере такой итератор будет ссылаться на элемент 7 списка l.
// Зачем это может потребоваться?
// Вот пример:

l.erase(
    std::copy(v.begin(), v.end(), l.begin()),
    l.end()
);
// удаляем все элементы в списке после тех, что были скопированы


// Реализация алгоритма copy могла бы выглядеть примерно так:
// (сравните это с функцией strcpy!)
template <typename IterFrom, typename IterTo>
IterTo copy(IterFrom from_first, IterFrom from_last, IterTo to_first) {
    while (from_first != from_last)
        *to_first++ = *from_first++;
    return to_first;
}


// Ещё один алгоритм - for_each.
// До синтаксиса цикла for по контейнеру, который появился в C++11, он довольно часто употреблялся.
// Этот алгоритм применяет указанную функцию к каждому элементу последовательности, заданной итераторами.

// Например, вот ещё один способ напечатать все элементы вектора.
#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    // ...
    std::for_each(
        v.begin(),
        v.end(),
        [](int x) { std::cout << x << " "; }  // подставляем лямбда-функцию в качестве аргумента
    );
}

// Алгоритм for_each может быть реализован так:
template <typename Iter, typename Function>
void for_each(Iter first, Iter last, Function f) {
    while (first != last) {
        f(*first);
        ++first;
    }
}

// (Вообще-то стандартная функция for_each ещё возвращает f, но вам пока может быть не очень понятно, зачем это нужно.
// Мы для простоты объявили for_each как void-функцию.)

// Вопрос из зала: а тут можно было бы ++ написать прямо в строке с вызовом f?
// Ответ: да, конечно:
f(*first++);


// Обратите внимание, что мы везде передаём в итераторы в функции "по значению" (а не по константной ссылке, например).
// Считается, что итераторы - достаточно "лёгкие" объекты, которые можно быстро и дёшево копировать.
// Кстати, именно так ведут себя указатели, которым итераторы подражают.
// Мы этим свойством явно пользуемся во всех этих функциях: сдвигаем итератор first до тех пор, пока он не дойдёт до last.
// На самом деле мы работаем с копией исходного итератора, поэтому это не создаёт никаких проблем.

