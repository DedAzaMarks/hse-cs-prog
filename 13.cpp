// Сегодня объявляется второе домашнее задание
// В одной из его задач потребуется считывать строку не до ближайшего пробельного разделителя,
// а целиком, до символа перевода строки
// Вот как это можно сделать:

#include <iostream>
#include <string>

int main() {
    std::string s;
    std::getline(std::cin, s); // считываем строчку целиком, включая пробелы и табуляции
    std::cout << s << ".\n";   // проверяем, что прочитали 
}

// Продолжаем разговаривать про массивы
// создадим, например, динамический массив размера N

size_t N;
std::cin >> N;
int * array = new int[N];
// Вспоминаем, что мы работаем с динамическим массивом через указатель на его начальный элемент

// Элементы такого динамического массива проинициализированы значением по умолчанию (нулем для типа int).
// Вот, например, его начальный элемент:
std::cout << *array << "\n"; // выводит 0

// Компилятор никак не проверяет (да и не особо может проверить) выход за границы диапазона.
// Поэтому вот такой код скомпилируется:
*(array + 123122) = 17; // то же, что и array[123122] = 17 - присваиваем значение очень далёкой от начала ячейке
std::cout << array[12343242] << "\n";
// но последствия такого запуска непредсказуемы.

// Возможно, операционная система просто прибьёт нашу программу, если она выйдет за пределы отведенного ей сегмента памяти
// (так называемая ошибка segmentation fault).

// А, может быть, операционная система этого и не заметит, и тогда произойдёт "проезд по памяти":
// мы незаконно изменим ячейку памяти, в которой хранится что-то чужое (например, другая переменная).
// После этого программа станет вести себя неопределённо (undefined behaviour).
// Задача программиста - никогда не допускать таких ошибок.

++array; // array - это указатель на начальный элемент.
// Сдвигаем его, и он начинает теперь указывать на следующий элемент массива (с индексом 1).

delete [] (array - 1);
// Удаляем массив, но передаем в delete[] сдвинутый обратно указатель, чтобы он указывал на начало.
// Если этого не сделать, или вызвать delete вместо delete[], то это - грубая ошибка, и снова неопределённое поведение.

// Договоримся, что любая динамически выделенная память обязательно должна быть освобождена.
// Если вы этого не сделаете, то будем считать, что в вашей программе происходит утечка памяти.

// Другая частая ошибка - когда путают new/new[] и delete/delete[].
// Напоминаю, что эти операторы без квадратных скобок должны использоваться для создания отдельных объектов, а не массивов.
int * p = new int;
std::cout << *p << "\n";
*p = 42;
std::cout << *p << "\n";
delete p;

// В языке C строки задавались как обычные массивы символов.
// В С++ есть класс стандантной библиотеки std::string, и всегда стоит использовать именно его.
// Но давайте познакомимся со "старыми" строками поближе.
// Это позволит лучше понять работу с указателями.
// Эти "старые" строки ещё называют null-terminated strings,
// потому что в конце каждого такого массива ставился специальный символ с кодом 0 ('\0'), обозначающий границу строки
// (не путать с символом перевода строки '\n'!)

char * s = new char[10]; // создаём массив из 10 символов в динамической памяти
// изначально все эти ячейки заполнены символом \0
std::cin >> s; // считываем туда символы (в надежде, что их количество будет меньше 10)
std::cout << s << "\n";

std::cin >> s; // попробуем ещё раз
std::cout << s << "\n";
for (size_t i = 0; i != 10; ++i) {
    std::cout << int(s[i]) << " "; // давайте посимвольно выведем содержимое массива: сначала код, потом - сам символ
    std::cout << s[i] << "\n";
}

// Если сначала ввести длинную строчку (например, "hello"), а потом - короткую ("hi"), то увидим следующее:
104 h
105 i
0     // этот символ с кодом 0 - "граница" второй введённой строки ("hi")
108 l // остатки старой строки "hello"
111 o
0     // оставшаяся "граница" старой строки
0     // этот и следующие нули остались от создания массива
0
0
0

delete [] s; // обязательно в конце освобождаем динамическую память!

