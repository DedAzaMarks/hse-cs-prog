// Disclaimer: не пытайтесь скомпилировать этот файл целиком как есть.
// Тут собраны фрагменты разных программ, которые нужно компилировать и запускать по отдельности.

// Общие слова про историю языка, про стандарты C++, про компиляторы и т. д.

// Напишем простейшую программу "Hello, world!"

#include <iostream>

int main() {
    std::cout << "Hello, world\n";
}


// Любая программа на C++ начинает исполнение с функции main.
// Здесь мы передаем строку (с завершающим символом перевода строки) в cout, то есть, на консоль.
// Директива #include ... подключает заголовочный библиотечный файл с именем iostream,
// в котором определен объект cout.


// Вопросы из зала про return 0, using namespace std и endl.

// Считается, что функция main должна возвращать целое число (значение типа int).
// Причем это число равно 0, если программа завершилась успешно.
// А если оно отлично от 0, то оно может обозначать код ошибки.

// Если функция имеет тип int, то из нее обязательно нужно что-то вернуть с помощью оператора return.
// Но для функции main сделано исключение: return 0 можно не писать. А можно было бы написать:

#include <iostream>

int main() {
    std::cout << "Hello, world\n";
    return 0;  // В функции main разрешается опускать этот return 0
}


// std:: - это префикс пространства имен, в котором собраны стандартные библиотечные сущности.
// Чтобы не писать его всякий раз, можно сделать так:

#include <iostream>

using namespace std;  // Делаем видимыми все имена из пространства имен std

int main() {
     cout << "Hello, world\n"; // поэтому можем использовать cout без префикса std::
}

// Но лучше - так:

#include <iostream>

using std::cout;  // Делаем видимым только cout

int main() {
    cout << "Hello, world\n";
}


// -------------------

// Напишем программу, спрашивающую имя пользователя и его возраст

#include <iostream>
#include <string>  // Требуется для типа std::string

using namespace std; // Для краткости дальнейшего кода все-таки подключим std целиком

int main() {
    cout << "What is your name?\n";
    string name;  // Объявляем переменную name типа std::string
    cin >> name;  // Считываем ее с клавиатуры. Обратите внимание на направление стрелок!
    cout << "Hello, " << name << "!\n";
    cout << "How old are you?\n";
    int age; // Объявляем целочисленную переменную age. Как правило, тип int занимает 4 байта памяти.
    cin >> age;
    cout << "You are " << age << " years old.\n";
}


// ---------------------

// Проверим с помощью условного оператора, что возраст корректен

#include <iostream>
#include <string>

using namespace std;

int main() {
    cout << "How old are you?\n";
    int age;
    cin >> age;
    if (age < 0) {
        cout << "Wrong age!\n";
        age = 18;
    } else {
        cout << "You are " << age << " years old.\n";
    }
}

// После if или else ожидается ровно один оператор.
// Если нам нужно написать их там несколько, то их надо объединить в блок с помощью фигурных скобок.
// Отступы при этом не важны, но их крайне рекомендуется аккуратно расставлять для удобства чтения кода.


// ---------------------

// Оператора elif в C++ нет. Вместо него можно использовать вложенные if'ы:

#include <iostream>

int main() {
    int x, y;
    std::cin >> x >> y;
    if (x < y) {
        std::cout << "Less\n";
    } else if (x == y) {
        std::cout << "Greater\n";
    } else {
        std::cout << "Equal\n";
    }
}

// Вопрос из зала: как понять, какой else к какому if'у относится?
// Ответ: всегда относится к ближайшему if'у. Сравните:

if (x <= y)
    if (x < y)
        std::cout << "Less\n";
    else
        std::cout << "Equal\n";
else
    std::cout << "Greater\n";


if (x <= y) {
    if (x < y)
        std::cout << "Less\n";
} else
    std::cout << "Greater\n";


// ---------------------

// В некоторых простых случаях можно воспользоваться оператором switch:

#include <iostream>

int main() {
    int x;
    std::cin >> x;
    switch (x) {  // "Прыгаем" на нужную метку в зависимости от значения x
        case 1:
            std::cout << "First action\n";
            break; // Если break не написать, то исполнение программы продолжится дальше
        case 2:
            std::cout << "Second action\n";
            break;
        case 3:
        case 4:
            std::cout << "Third or fourth action\n";
            break;
        default:
            std::cout << "Wrong action\n";
    }
    // break выходит из оператора switch и передает управление сюда
}

// ---------------------

// Цикл с предусловием

#include <iostream>

int main() {
    int n;
    std::cin >> n;
    // Печатаем таблицу квадратов в обратном порядке
    while (n > 0) {
		cout << n << "\t" << n * n << "\n";
		--n; // Уменьшаем n на единицу
    }
}


// То же, но в прямом порядке:

#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int i = 1;
    while (i <= n) {
		cout << i << "\t" << i * i << "\n";
		++i;
    }
}


// ---------------------

// Цикл for

#include <iostream>

int main() {
    int n;
    std::cin >> n;
    for (int i = 1; i <= n; ++i) {
		cout << i << "\t" << i * i << "\n";
    }
}

// Синтаксис цикла for:
// for (инициализация; условие продолжения; действие) {
//    операторы;
// }

// Существуют операторы break и continue для выхода из цикла и перехода на следующую итерацию


// ---------------------

// Оператор безусловного перехода goto - ругательное слово из четырех букв.
// Он затрудняет чтение кода. Любую программу можно переписать без него.
// Почему же его оставили в C++? Какие были причины кроме обратной совместимости?
// Оказывается он очень удобен, например, в автоматически генерируемых программах
// (реализующих, скажем, конечный автомат)

#include <iostream>

int main() {
    std::cout << "Input a positive value\n";
    int n;
    start:  // метка
    std::cin >> n;
    if (n <= 0)
        goto start;
    std::cout << "The value is " << n << "\n";
}

// Лучше переписать эту программу с помощью цикла с постусловием:

#include <iostream>

int main() {
    std::cout << "Input a positive value\n";
    int n;
    do {
        std::cin >> n;
    } while (n <= 0);
    std::cout << "The value is " << n << "\n";
}


// ---------------------

// Напоследок познакомимся с векторами ("умными" динамическими массивами)

#include <iostream>
#include <vector>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};  // вектор из пяти элементов

    for (int i = 1; i != 5; ++i) { // считаем с клавиатуры и добавим в конец еще пять элементов
        int x;
        std::cin >> x;
        v.push_back(x);
    }

    for (int elem : v) { // переберем и напечатаем эти 10 элементов
        std::cout << elem << " ";
    std::cout << "\n";
}


