// В прошлый раз мы написали класс "Комплексное число".
// Действительная и мнимая части комплексного числа имели тип double.

// На самом деле было бы удобно иметь возможность настраивать этот тип.
// Например, рассматривать целые гауссовы числа - комплексные числа с целыми коэффициентами.

// Сделаем тип коэффициентов комплексного числа шаблонным параметром
// (на самом деле именно так устроен стандартный std::complex):
// Для этого, грубо говоря, заменим везде double на T

template <typename T> // можно писать и template <class T>
class Complex {
private:
    T x, y;
public:
    Complex(T a = 0, T b = 0): x(a), y(b) {
    }

    const T Re() const {
        return x;
    }

    T Im() const {
        return y;
    }
};

template <typename T>
Complex<T> operator + (const Complex<T>& u, const Complex<T>& v) {
    Complex<T> z(u.Re() + v.Re(), u.Im() + v.Im());
    return z;
}

// Мы описали не конкретный класс, а шаблон, образец,
// по которому уже будут при необходимости строиться конкретные классы для каждого значения типа T

int main() {
    Complex<double> w(1.5, -2.5);  // тут строим по образцу класс Complex<double>
    Complex<int> z(2, -3);  // а тут строим по образцу класс Complex<int>
    Complex<double> w2; // класс Complex<double> уже был построен, используем его
    Complex<std::vector<int>> strange; // а это не скомпилируется: вектор нельзя проинициализировать нулём (как в конструкторе Complex)
}


// Шаблонными параметрами могут быть не только типы, но и, например, целые числа.
// Важно только, чтобы такие параметры были известны компилятору во время компиляции.

// Напишем класс "Квадратная матрица" фиксированного размера N x N:
// Тип коэффициентов матрицы тоже сделаем шаблонным.

#include <iostream>

template <typename T, int N>
class Matrix {
private:
    T data[N][N]; // поскольку N - константа времени компиляции, можно хранить матрицу просто в статическом массиве
public:
    Matrix(const T& lambda = 0) { // по умолчанию создаём скалярную матрицу с элементом lambda на диагонали
        for (size_t i = 0; i != N; ++i)
            for (size_t j = 0; j != N; ++j)
                data[i][j] = (i == j) ? lambda : 0; // все другие элементы надо заполнить нулями, они автоматически не инициализируются
    }

    T& operator() (size_t i, size_t j) { // оператор "круглые скобки" для доступа к элементам матрицы
        return data[i][j]; // возвращается ссылка, так что элементы можно будет менять
    }

    const T& operator() (size_t i, size_t j) const { // константная версия этого же оператора
        return data[i][j]; // она будет применяться к матрицам-константам и не позволит изменять элементы матрицы
    }

    // Мы могли бы перегрузить вместо "круглых скобок" и оператор "квадратные скобки", но в него можно передать только один индекс.
    // Тогда такой оператор должен был бы возвращать "строку" матрицы, у которой, в свою очередь, должен быть свой оператор "квадратные скобки".
    // В роли такой строки в нашем случае как раз мог бы выступать массив. Его надо возвращать из функции как указатель:
    T * operator [] (size_t i) {
        return data[i];
    }

    const T * operator [] (size_t i) const {
        return data[i];
    }


    Matrix& operator += (const Matrix& other) { // Понимаете, почему здесь возвращается ссылка и в конце нет const?
        for (size_t i = 0; i != N; ++i)
            for (size_t j = 0; i != N; ++j)
                data[i][j] += other.data[i][j];
        return *this; // канонические операторы типа присваивания вовзращают ссылку на тот объект, которому что-то присвоили
    }

    // Реализация оператора + как внутреннего оператора в классе
    Matrix operator + (const Matrix& other) const { // возвращаем новую матрицу - поэтому по значению, а не по ссылке.
        // текущий объект (левую часть) не изменяем - поэтому const в конце
        Matrix<T, N> C(*this); // конструктор копирования, неявно созданный компилятором
        C += other;
        return C;
    }
};

// Для сравнения реализуем оператор умножения матриц внешним образом
template <typename T, int N> // он тоже будет шаблонным
Matrix<T, N> operator * (const Matrix<T, N>& A, const Matrix<T, N>& B) { // и левая, и правая часть передаются по константной ссылке
    Matrix<T, N> C;
    for (size_t i = 0; i != N; ++i)
        for (size_t j = 0; j != N; ++j
            for (size_t k = 0; k != N; ++k)
                C(i, j) += A(i, k) * B(k, j); // слева от присваивания вызов неконстантного оператора (), справа - вызов константных операторов
    return C; // тут нельзя возвращать ссылку! Только значение! Ссылка на локальный объект тут же станет невалидной.
}

// Редкий случай, когда оператор вида @= удобнее реализовать через оператор @, а не наоборот
template <typename T, int N>
Matrix<T, N>& operator *= (Matrix<T, N>& A, const Matrix<T, N>& B) { // обратите внимание, что первый аргумент - не const, он меняется
    A = A * B;
    return A; // возвращаем ссылку на левую часть
}

// А это - оператор вывода в поток.
// Хочется печатать матрицы каскадно: std::cout << A << "\n" << B << "\n";
// Для этого (std::cout << A) снова должен возвращать объект std::cout.
// Заметим, что на месте std::cout может быть произвольный поток вывода (например, связанный с файлом, а не с экраном).
template <typename T, int N>
std::ostream& operator << (std::ostream& out, const Matrix<T, N>& A) {
    for (size_t i = 0; i != N; ++i) {
        for (size_t j = 0; j != N; ++j)
            out << A(i, j) << "\t"; // обратите внимание: печатаем в переданный поток out, а не в конкретный std::cout
        out << "\n";
    }
    return out; // возвращаем ссылку на этот же поток, чтобы можно было составлять каскады из <<
}

// Аналогично пишется и перегрузка оператора >> для типа std::istream.


int main() {
    // В нашей модели размер матрицы должен быть зафиксирован на стадии компиляции!
    Matrix<int, 3> A(5); // матрица 3x3 с пятёрками на диагонали
    Matrix<int, 3> B; // нулевая матрица 3x3

    B(0, 1) = B(1, 2) = 3;
    A(1, 2) = A(2, 2) = -1;
    A *= B; // умножить друг на друга можно только матрицы с одинаковым размером и с одинаковым типом коэффиицентов

    std::cout << A << "\n" << B << "\n";
}

