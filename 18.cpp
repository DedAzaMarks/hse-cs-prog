// Сегодня мы продолжаем рассматривать алгоритмы стандартной библиотеки.
// Напоминаю, что под алгоритмами здесь понимаются стандартные шаблонные функции,
// как-то обрабатывающие последовательности элементов, заданные итераторами.
// Их удобно смотреть на http://en.cppreference.com/w/cpp/algorithm
// (русская версия --- http://ru.cppreference.com/w/cpp/algorithm, но я предпочитаю английскую).
// Для каждого алгоритма на cppreference приведена его возможная реализация.
// Там же прямо через браузер можно запустить примеры кода и посмотреть на результаты работы.

// (Далее мы долго смотрим на cppreference и говорим про каждый алгоритм.)


// Обратите внимание, что

// -- алгоритмы делятся на "немодифицирующие" и "модифицирующие последовательность";

// -- модифицирующие алгоритмы (например, copy) получают на вход один выходной итератор.
// Считается, что они заполняют последовательность, начиная с этого итератора,
// и возвращают итератор, указывающий за последний записанный элемент.

// -- у ряда функций в имени есть суффикс "_if" (например, count_if).
// Такие алгоритмы получают на вход дополнительный аргумент - функцию, которая будет вызываться для каждого элемента последовательности.
// Вместо функции в такие алгоритмы бывает удобно передать объект класса с перегруженным оператором вызова ("круглые скобки"):

#include "iostream"
#include "vector"

struct Comparer {
    size_t counter = 0;
    bool operator () (int a, int b) {  // ведет себя как оператор <, но подсчитывает число вызовов
        ++counter;
        return a < b;
    }
};

int main() {
    std::vector<int> v = {3, 14, 15, 92, 6};
    Comparer c;
    std::sort(v.begin(), v.end(), c);  // объект с ведет себя как функция - его можно "вызывать" с помощью круглых скобок
    std::cout << c.counter << "\n"; // сколько раз вызывалась функция сравнения?
}

// Вот ещё пример: убираем из строки все пробельные символы

#include <algorithm>
#include <iostream>
#include <string>
#include <cctype>

int main() {
    std::string s = "  Hello, world!";
    // Перемещаем пробелы. Возвращается итератор, претендующий на то, чтобы быть "новым end'ом"
    auto iter = std::remove_if(s.begin(), s.end(), [] (char x) { return std::isspace(x); });
    std::cout << s << "\n";  // Выведет "Hello,world!ld!"
    s.erase(iter, s.end());  // А вот теперь удалим остатки физически!
    std::cout << s << "\n";  // Теперь выведет "Hello,world!"
}

// Вопрос: а почему бы здесь просто не написать std::isspace вместо лямбда-функции?
// Ответ: это нельзя, потому что, оказывается, isspace в некоторых реализация стандартной библиотеки
// является макросом, а не функцией!

// Важное замечание: функция remove или remove_if сама по себе ничего не может физически удалить.
// Она работает только с итераторами, которые описывают логическую последовательность элементов.
// Но эта функция ничего не знает про физическое хранение элементов в контейнере.
// Максимум, что она может сделать - как-то поменять сами элементы, на которые ссылаются итераторы.

// В данном случае функция remove_if переставляет символы в строке, чтобы пробел "схлопнулся".
// Но это не значит, что этот пробел оказывается в конце.
// В конце остается "мусор" от старых символов:

// Было:
// |   |   | H | e | l | l | o | , |   | w | o | r | l | d | ! | \0 |
//                                                             ^
//                                                             старое значение s.end()
// Стало:
// | H | e | l | l | o | , | w | o | r | l | d | ! | l | d | ! | \0 |
//                                                 ^
//                                                 этот итератор ("новый end") вернула remove_if


// Вопрос: почему функции, принимающие предикат (функцию), а не значение, имеют в названии суффикс _if?
// Разве нельзя их было назвать так же, как и основную функцию? Например, не remove_if, а remove?

// Ответ: эти функции шаблонные. Например, remove объявляется так:
template< class Iter, class T>
Iter remove(Iter first, Iter last, const T& value);

// А remove_if - так:
template< class Iter, class UnaryPredicate>
Iter remove_if(Iter first, Iter last, UnaryPredicate p);

// Если бы у них были одинаковые имена, то отличить первую от второй было бы невозможно.


// Ещё одна полезная группа алгоритмов - алгоритмы для работы с отсортированными последовательностями.
// Эти алгоритмы содержат в имени префикс set_.
// Это не должно вводить в заблуждение:
// применять их можно не только к итераторам контейнера set, но к любым упорядоченным последовательностям.
// (хотя с set'ом их применение очень естественно, так как он хранит элементы упорядоченно).
// Они позволяют найти объединение, пересечение, разность и симметрическую разность упорядоченных интервалов.

// Например, находим общие числа в двух последовательностях.
// Если в последовательностях есть повторения, то учтём и их тоже.
#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v1, v2;
    int n1, n2, x;
    std::cin >> n1;
    while (n1-->0) {
    	std::cin >> x;
    	v1.push_back(x);
    }
    std::cin >> n2;
    while (n2-->0) {
    	std::cin >> x;
    	v2.push_back(x);
    }

    // Последовательности должны быть отсортированы!
    std::sort(v1.begin(), v1.end());
    std::sort(v2.begin(), v2.end());

    std::vector<int> results;

    // Если какое-то число x повторялось в v1 m раз, а в v2 - n раз, то в results оно встретится min(m, n) раз.
    std::set_intersection(
          v1.begin(), v1.end(),
          v2.begin(), v2.end(),
          std::back_inserter(results) // умный итератор, умеющий вставлять элементы с помощью push_back'а при записи
    );

    for (int elem : results)
    	std::cout << elem << " ";
}

