// Напишем класс "Комлексное число".
// Заметим, что в стандартной библиотеке C++ уже есть шаблонный класс std::complex.
// Но мы напишем свой в качестве упражнения.

#include <cmath>
#include <iostream>

class Complex {  // от слова struct ключевое слово class отличается тем, что все имена по умолчанию считаются в классе "закрытыми"
// старайтесь использовать struct тогда, когда имеете дело просто с набором данных,
// а слово class - когда еще предполагаются нетривиальные действия по их обработке (создание или уничтожение объекта, различные операции и т. д.)
private: // имена, объявленные в разделе private, будут доступны только в коде функций-членов самого класса
    double x, y; // действительная и мнимая часть
public: // имена, объявленные в public, будут доступны всюду
    // Это - конструктор. Он создает новое комплексное число по действительной и мнимой частям.
    // По умолчанию эти части равны нулю.
    Complex(double a = 0.0, double b = 0.0): x(a), y(b) {
    }

    double Re() const { // Это функции-getter'ы. Они позволяют получить действительную и мнимую часть, но не позволяют её изменить.
        return x;       // Такая функция всегда вызывается для какого-то конкретного объекта. Здесь мы обращаемся к его полю x.
    }

    double Im() const { // Обратите внимание на const. Он означает, что текущий объект эта функция не изменяет. Подробности - ниже.
        return y;
    }

    double abs() const { // Модуль комплексного числа; можно так же описать и функцию, возвращающую аргумент.
        return sqrt(x * x + y * y);
    }
};

// Давайте теперь снаружи класса опишем ("перегрузим") арифметические операторы:
Complex operator + (const Complex& u, const Complex& v) {
    Complex z(u.Re() + v.Re(), u.Im() + v.Im()); // вызовы Re и Im тут работают, а обращение к x и y - уже нет.
    return z; // можно было бы и в одну строчку записать return Complex(...), но так понятнее.
}

Complex operator * (const Complex& u, const Complex& v) {
    Complex z(u.Re() * v.Re() - u.Im() * v.Im(), u.Re() * v.Im() + u.Im() * v.Re());
    return z;
}

// Напишите другие арифметические операторы самостоятельно

// Попробуем запустить:
int main() {
    Complex u(1.0, 2.5); // 1 + 2.5 i
    Complex v(-5.0);     // -5 + 0 i

    Complex z1 = u + v;
    Complex z2 = u * v;

    std::cout << z1.Re() << " " << z1.Im() << "\n";
    std::cout << z2.Re() << " " << z2.Im() << "\n";
}


// Можно было бы добавить в наш класс операторы += и ему подобные:
class Complex {
// ...
public:
    Complex& operator += (const Complex& other) { // понимаете, почему этот оператор не является константным?
        x += other.x;
        y += other.y;
        return *this; // Операторы типа присваивания всегда возвращают ссылку на то, что было присвоено.
        // this - это ключевое слово, обозначающее указатель на текущий объект.
    }
};

// Считается, что a += b должно работать эффективнее, чем a = a + b (временные объекты не должны создаваться).
// Тогда реализация оператора + могла бы быть такой:
Complex operator + (const Complex& u, const Complex& v) {
    Complex z(u); // конструктор копирования, предоставленный компилятором по умолчанию
    z += v; // реализуем + через +=
    return z;
}



// Кстати, заметим, что если бы, например, у функций-членов Re и Im не было бы пометы const в конце заголовка,
// то эти функции не получилось бы применить к костантному объекту:

class Complex {
// ...
public:
    double Re() { // нет const, потенциальная ошибка!
        // ...
    }
};

int main() {
    const Complex z;
    std::cout << z.Re(); // не компилируется!
}

// Дело в том, что компилятор разрешает применять к константам только "константные" функции, чтобы быть уверенным, что не изменят объект.
// В свою очередь, в каждой "константной" функции компилятор тоже делает такую проверку.

// Мораль: если функция-член класса по смыслу не меняет состояние объекта, объявите её константной.
// Можно сказать и по-другому: в константную функцию неявно передается не указатель Complex * const this, а указатель const Complex * const this.



// Вопрос: а для чего, собственно, мы делаем поля x и у закрытыми (приватными)?
// Во-первых, в нашей реализации класса мы так защищаем их от несанкционированного изменения:
// внешний код их может только читать с помощью функций Re и Im, но не может напрямую изменять.

// Во-вторых, это общий принцип: скрывать внутренние детали реализации, и открывать только общий интерфейс.
// Тогда детали реализации можно будет при необходимости изменить, не меняя код всех внешних программ, которые используют наш класс.
// Например, предположим, что мы хотим теперь хранить комплексное число не в алгебраической, а в тригонометрической форме.
// Что для этого нам надо поменять?

class Complex {
private:
    double r, phi;  // модуль и аргумент
public:
    Complex(double a = 0.0, double b = 0.0) { // конструктор по-прежнему должен принимать действительную и мнимую часть
        r = sqrt(a * a + b * b);
        phi = atan2(a, b); // есть такая удобная функция в cmath
    }

    double Re() const {
        return r * cos(phi);
    }

    double Im() const {
        return r * sin(phi);
    }

    double Abs() const { // теперь Re и Im вычисляют значения, зато Abs возвращает уже готовое
        return r;
    }

    Complex& operator += (const Complex& other) {
        // теперь его реализовать не так просто - проще переписать через +, а + написать явно
        return *this;
    }

    // зато очень просто реализовать умножение:
    Complex& operator *= (const Complex& other) {
        r *= other.r;
        phi += other.phi;
        // тут хорошо бы еще привести phi к полуинтервалу (-pi, pi] по модулю 2pi, чтобы не было неоднозначностей
    }
};

// Обратите внимание, что мы поменяли скрытую реализацию,
// но нигде не меняли внешние функции, которые полагаются только на открытый интерфейс


// Эту идею с сокрытием внутренней реализации удобно еще раз проиллюстрировать на классе "Дата", который некоторые из вас писали во второй домашней работе.
// Напомню задачу: надо уметь вычислять количество дней между датами и т. д.
// Удобно обернуть дату (день + месяц + год) в класс:

class Date {
private:
    int day, month, year;
public:
    Date(int d, int m, int y)
        : day(d)    // догадайтесь, почему удобно использовать такое выравнивание при инициализации полей?
        , month(m)
        , year(y)
    {
    }

    int GetDay() const {
        return day;
    }

    int GetMonth() const {
        return month;
    }

    int GetYear() const {
        return year;
    }

    Date& operator ++ () { // префиксный ++
        // добавляем один день к дате...
        return *this;
    }

    Date& operator -- () { // префиксный --
        // вычитаем один день из даты...
        return *this;
    }

    int operator - (const Date& other) const { // оператор "минус" для количества дней между датами
        // поскольку мы реализуем этот оператор внутри класса,
        // то его левая часть этого оператора передается неявно - это текущий объект, на него указывает *this,
        // a other - это правая часть нашего оператора

        // вычисляем и возвращаем количество дней между other и *this...
    }
};

// Теперь предположим, что мы решили поменять реализацию:
// вместо дня, месяца и года хотим хранить число дней, прошедших с начала некоторой эпохи.
// Спокойно меняем private-поля, переписываем открытые функции-члены.
// А все внешние программы этого даже не замечают, поскольку они private-поля и не могли использовать.

class Date {
private:
    int days_from_beginning;
public:
    Date(int d, int m, int y) {
        // некоторые действия по инициализации нашего нового поля
    }

    int GetDay() const; // эти функции становятся уже не такими тривиальными...
    int GetMonth() const;
    int GetYear() const;

    // Зато вот эти функции теперь пишутся легко:
    Date& operator ++ () {
        ++days_from_beginning;
        return *this;
    }

    Date& operator -- () {
        --days_from_beginning;;
        return *this;
    }

    int operator - (const Date& other) const {
        return days_from_beginning - other.days_from_beginning;
    }
};


// Вопрос из зала: а как перегружать постфиксный ++?
// Ответ: надо объявить его с фиктивным параметром типа int:
Date operator ++ (int) {
    Date temp(*this);
    ++days_from_beginning;
    return temp;
}

// Помните, что канонический постфиксный ++ (для чисел) возвращает копию старого (неизмененного) объекта?
// Поэтому и для дат имеет смысл реализовывать его именно так, как написано.

// Кстати, обратите внимание, что очень важно в этом случае вернуть Date, а не Date&.
// Если бы мы возвращали тут Date&, то получилась бы невалидная ссылка на временный объект temp,
// который при достижении закрывающей фигурной скобки умирает.



// Вопрос: в чём разница между this->days_from_beginning и просто days_from_beginning?
// Ответ: разницы нет, но второй способ лаконичнее и предпочтительнее.



// И, наконец, развеем некоторые неправильное понимание.
// Пусть есть класс:
class C {
public:
    void f(int x) const {
        // ...
    }
};

// Функция f и объявлена, и определена внутри класса.
// Вызываться она может так:

C object;
object.f(42); // указатель на объект, для которого вызывается эта функция, всегда неявно передаётся в неё как this.

// Но внутри класса можно оставить только её объявление (декларацию), а определение вынести наружу:
class C {
public:
    void f(int x) const; // тело функции будет дано позже
};

void C::f(int x) const { // обратите внимание на префикс C::
    // ... вот это тело
}


// Другое дело - функция, определённая внешним образом:
class C {
public:
    // ...
};

void f(const C& obj, int x) {
    // ...
}

// Обратите внимание: вместо *this тут теперь явно передаётся obj. 
// Он уже имеет помету константности, так что никакой const в конце функции тут не нужен (да он и невозможен).

// Вызывать такую функцию теперь нужно так:
C object;
f(object, 42);

// Всё сказанное, конечно, относится и к операторам.

